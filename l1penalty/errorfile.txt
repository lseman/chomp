In file included from /data/exact-penalty/pyver/src/pointWork.cpp:9:
/data/exact-penalty/pyver/src/Helpers.hpp: In function ‘Eigen::VectorXd& shiftPoint(Eigen::VectorXd&, const Eigen::VectorXd&)’:
/data/exact-penalty/pyver/src/Helpers.hpp:7:12: warning: reference to local variable ‘x_shifted’ returned [-Wreturn-local-addr]
    7 |     return x_shifted;
      |            ^~~~~~~~~
/data/exact-penalty/pyver/src/Helpers.hpp:6:21: note: declared here
    6 |     Eigen::VectorXd x_shifted = x - shift_center;
      |                     ^~~~~~~~~
In file included from /data/exact-penalty/pyver/src/l1Solver.hpp:10,
                 from /data/exact-penalty/pyver/src/main.cpp:9:
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘std::vector<double> TRModel::centerPoint() const’:
/data/exact-penalty/pyver/src/TRModel.hpp:49:38: error: could not convert ‘((const Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 0>*)(&((const TRModel*)this)->TRModel::pointsAbs))->Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 0>::operator[](((Eigen::Index)((size_t)((const TRModel*)this)->TRModel::trCenter)))’ from ‘const double’ to ‘std::vector<double>’
   49 |             return pointsAbs[trCenter];
      |                                      ^
      |                                      |
      |                                      const double
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘std::vector<double> TRModel::firstPoint() const’:
/data/exact-penalty/pyver/src/TRModel.hpp:58:31: error: could not convert ‘((const Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 0>*)(&((const TRModel*)this)->TRModel::pointsAbs))->Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 0>::operator[](0)’ from ‘const double’ to ‘std::vector<double>’
   58 |             return pointsAbs[0];
      |                               ^
      |                               |
      |                               const double
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘void TRModel::shiftPoints()’:
/data/exact-penalty/pyver/src/TRModel.hpp:78:71: error: ‘Eigen::MatrixXd’ {aka ‘class Eigen::Matrix<double, -1, -1>’} has no member named ‘push_back’
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                       ^~~~~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp:78:94: error: no match for ‘operator-’ (operand types are ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’} and ‘std::vector<double>’)
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/string:48,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/ios:44,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/ostream:40,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/iostream:41,
                 from /data/exact-penalty/pyver/src/main.cpp:1:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:625:5: note: candidate: ‘template<class _IteratorL, class _IteratorR> constexpr decltype ((__y.base() - __x.base())) std::operator-(const reverse_iterator<_IteratorL>&, const reverse_iterator<_IteratorR>&)’
  625 |     operator-(const reverse_iterator<_IteratorL>& __x,
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:625:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::reverse_iterator<_IteratorL>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:1800:5: note: candidate: ‘template<class _IteratorL, class _IteratorR> constexpr decltype ((__x.base() - __y.base())) std::operator-(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&)’
 1800 |     operator-(const move_iterator<_IteratorL>& __x,
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:1800:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::move_iterator<_IteratorL>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:48,
                 from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Dense:1,
                 from /data/exact-penalty/pyver/src/main.cpp:2:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:365:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&, const complex<_Tp>&)’
  365 |     operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:365:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::complex<_Tp>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:374:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&, const _Tp&)’
  374 |     operator-(const complex<_Tp>& __x, const _Tp& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:374:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::complex<_Tp>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:383:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const _Tp&, const complex<_Tp>&)’
  383 |     operator-(const _Tp& __x, const complex<_Tp>& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:383:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:460:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&)’
  460 |     operator-(const complex<_Tp>& __x)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:460:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::complex<_Tp>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘void TRModel::updatePoint(size_t, Eigen::VectorXd&, Eigen::VectorXd)’:
/data/exact-penalty/pyver/src/TRModel.hpp:94:32: error: cannot convert ‘Eigen::VectorXd’ {aka ‘Eigen::Matrix<double, -1, 1>’} to ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’} in assignment
   94 |             pointsAbs[index] = point;
      |                                ^~~~~
      |                                |
      |                                Eigen::VectorXd {aka Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/TRModel.hpp:95:32: error: cannot convert ‘Eigen::VectorXd’ {aka ‘Eigen::Matrix<double, -1, 1>’} to ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, 1>, 1>::Scalar’ {aka ‘double’} in assignment
   95 |             fValues[index]   = fValue;
      |                                ^~~~~~
      |                                |
      |                                Eigen::VectorXd {aka Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/TRModel.hpp:96:25: error: cannot convert ‘Eigen::VectorXd’ {aka ‘Eigen::Matrix<double, -1, 1>’} to ‘const std::vector<double>&’
   96 |             updateCache(point, fValue);
      |                         ^~~~~
      |                         |
      |                         Eigen::VectorXd {aka Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/TRModel.hpp:82:49: note:   initializing argument 1 of ‘void TRModel::updateCache(const std::vector<double>&, double)’
   82 |     void updateCache(const std::vector<double> &point, double fValue) {
      |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~
In file included from /data/exact-penalty/pyver/src/l1Solver.hpp:10,
                 from /data/exact-penalty/pyver/src/Aux.cpp:12:
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘std::vector<double> TRModel::centerPoint() const’:
/data/exact-penalty/pyver/src/TRModel.hpp:49:38: error: could not convert ‘((const Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 0>*)(&((const TRModel*)this)->TRModel::pointsAbs))->Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 0>::operator[](((Eigen::Index)((size_t)((const TRModel*)this)->TRModel::trCenter)))’ from ‘const double’ to ‘std::vector<double>’
   49 |             return pointsAbs[trCenter];
      |                                      ^
      |                                      |
      |                                      const double
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘std::vector<double> TRModel::firstPoint() const’:
/data/exact-penalty/pyver/src/TRModel.hpp:58:31: error: could not convert ‘((const Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 0>*)(&((const TRModel*)this)->TRModel::pointsAbs))->Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 0>::operator[](0)’ from ‘const double’ to ‘std::vector<double>’
   58 |             return pointsAbs[0];
      |                               ^
      |                               |
      |                               const double
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘void TRModel::shiftPoints()’:
/data/exact-penalty/pyver/src/TRModel.hpp:78:71: error: ‘Eigen::MatrixXd’ {aka ‘class Eigen::Matrix<double, -1, -1>’} has no member named ‘push_back’
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                       ^~~~~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp:78:94: error: no match for ‘operator-’ (operand types are ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’} and ‘std::vector<double>’)
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/string:48,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/ios:44,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/ostream:40,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/iostream:41,
                 from /data/exact-penalty/pyver/src/Aux.cpp:1:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:625:5: note: candidate: ‘template<class _IteratorL, class _IteratorR> constexpr decltype ((__y.base() - __x.base())) std::operator-(const reverse_iterator<_IteratorL>&, const reverse_iterator<_IteratorR>&)’
  625 |     operator-(const reverse_iterator<_IteratorL>& __x,
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:625:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::reverse_iterator<_IteratorL>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:1800:5: note: candidate: ‘template<class _IteratorL, class _IteratorR> constexpr decltype ((__x.base() - __y.base())) std::operator-(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&)’
 1800 |     operator-(const move_iterator<_IteratorL>& __x,
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:1800:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::move_iterator<_IteratorL>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:48,
                 from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Dense:1,
                 from /data/exact-penalty/pyver/src/Aux.cpp:2:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:365:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&, const complex<_Tp>&)’
  365 |     operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:365:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::complex<_Tp>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:374:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&, const _Tp&)’
  374 |     operator-(const complex<_Tp>& __x, const _Tp& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:374:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::complex<_Tp>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:383:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const _Tp&, const complex<_Tp>&)’
  383 |     operator-(const _Tp& __x, const complex<_Tp>& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:383:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:460:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&)’
  460 |     operator-(const complex<_Tp>& __x)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:460:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::complex<_Tp>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘void TRModel::updatePoint(size_t, Eigen::VectorXd&, Eigen::VectorXd)’:
/data/exact-penalty/pyver/src/TRModel.hpp:94:32: error: cannot convert ‘Eigen::VectorXd’ {aka ‘Eigen::Matrix<double, -1, 1>’} to ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’} in assignment
   94 |             pointsAbs[index] = point;
      |                                ^~~~~
      |                                |
      |                                Eigen::VectorXd {aka Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/TRModel.hpp:95:32: error: cannot convert ‘Eigen::VectorXd’ {aka ‘Eigen::Matrix<double, -1, 1>’} to ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, 1>, 1>::Scalar’ {aka ‘double’} in assignment
   95 |             fValues[index]   = fValue;
      |                                ^~~~~~
      |                                |
      |                                Eigen::VectorXd {aka Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘bool TRModel::isLambdaPoised(const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/TRModel.hpp:107:33: error: invalid operands of types ‘const std::map<std::__cxx11::basic_string<char>, double>::mapped_type’ {aka ‘const double’} and ‘const char [6]’ to binary ‘operator==’
  107 |         if (options.at("basis") == "dummy") {
      |             ~~~~~~~~~~~~~~~~~~~ ^~ ~~~~~~~
      |                       |            |
      |                       |            const char [6]
      |                       const std::map<std::__cxx11::basic_string<char>, double>::mapped_type {aka const double}
/data/exact-penalty/pyver/src/TRModel.hpp:96:25: error: cannot convert ‘Eigen::VectorXd’ {aka ‘Eigen::Matrix<double, -1, 1>’} to ‘const std::vector<double>&’
   96 |             updateCache(point, fValue);
      |                         ^~~~~
      |                         |
      |                         Eigen::VectorXd {aka Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/TRModel.hpp:82:49: note:   initializing argument 1 of ‘void TRModel::updateCache(const std::vector<double>&, double)’
   82 |     void updateCache(const std::vector<double> &point, double fValue) {
      |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘bool TRModel::isComplete()’:
/data/exact-penalty/pyver/src/TRModel.hpp:122:36: error: ‘class TRModel’ has no member named ‘pivotPolynomial’; did you mean ‘pivotPolynomials’?
  122 |         int maxTermsUnused = this->pivotPolynomial.size();
      |                                    ^~~~~~~~~~~~~~~
      |                                    pivotPolynomials
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘bool TRModel::isOld(const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/TRModel.hpp:133:51: error: no match for ‘operator-’ (operand types are ‘std::vector<double>’ and ‘std::vector<double>’)
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                ~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~
      |                                                |                     |
      |                                                vector<[...]>         vector<[...]>
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:625:5: note: candidate: ‘template<class _IteratorL, class _IteratorR> constexpr decltype ((__y.base() - __x.base())) std::operator-(const reverse_iterator<_IteratorL>&, const reverse_iterator<_IteratorR>&)’
  625 |     operator-(const reverse_iterator<_IteratorL>& __x,
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:625:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::reverse_iterator<_IteratorL>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:1800:5: note: candidate: ‘template<class _IteratorL, class _IteratorR> constexpr decltype ((__x.base() - __y.base())) std::operator-(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&)’
 1800 |     operator-(const move_iterator<_IteratorL>& __x,
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:1800:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::move_iterator<_IteratorL>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:365:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&, const complex<_Tp>&)’
  365 |     operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:365:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:374:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&, const _Tp&)’
  374 |     operator-(const complex<_Tp>& __x, const _Tp& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:374:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:383:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const _Tp&, const complex<_Tp>&)’
  383 |     operator-(const _Tp& __x, const complex<_Tp>& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:383:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:460:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&)’
  460 |     operator-(const complex<_Tp>& __x)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:460:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/data/exact-penalty/pyver/src/TRModel.hpp:133:98: error: expected primary-expression before ‘)’ token
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                                                  ^
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘bool TRModel::isLambdaPoised(const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/TRModel.hpp:107:33: error: invalid operands of types ‘const std::map<std::__cxx11::basic_string<char>, double>::mapped_type’ {aka ‘const double’} and ‘const char [6]’ to binary ‘operator==’
  107 |         if (options.at("basis") == "dummy") {
      |             ~~~~~~~~~~~~~~~~~~~ ^~ ~~~~~~~
      |                       |            |
      |                       |            const char [6]
      |                       const std::map<std::__cxx11::basic_string<char>, double>::mapped_type {aka const double}
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘bool TRModel::isComplete()’:
/data/exact-penalty/pyver/src/TRModel.hpp:122:36: error: ‘class TRModel’ has no member named ‘pivotPolynomial’; did you mean ‘pivotPolynomials’?
  122 |         int maxTermsUnused = this->pivotPolynomial.size();
      |                                    ^~~~~~~~~~~~~~~
      |                                    pivotPolynomials
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘bool TRModel::isOld(const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/TRModel.hpp:133:51: error: no match for ‘operator-’ (operand types are ‘std::vector<double>’ and ‘std::vector<double>’)
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                ~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~
      |                                                |                     |
      |                                                vector<[...]>         vector<[...]>
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:625:5: note: candidate: ‘template<class _IteratorL, class _IteratorR> constexpr decltype ((__y.base() - __x.base())) std::operator-(const reverse_iterator<_IteratorL>&, const reverse_iterator<_IteratorR>&)’
  625 |     operator-(const reverse_iterator<_IteratorL>& __x,
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:625:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::reverse_iterator<_IteratorL>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:1800:5: note: candidate: ‘template<class _IteratorL, class _IteratorR> constexpr decltype ((__x.base() - __y.base())) std::operator-(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&)’
 1800 |     operator-(const move_iterator<_IteratorL>& __x,
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:1800:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::move_iterator<_IteratorL>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:365:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&, const complex<_Tp>&)’
  365 |     operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:365:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:374:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&, const _Tp&)’
  374 |     operator-(const complex<_Tp>& __x, const _Tp& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:374:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:383:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const _Tp&, const complex<_Tp>&)’
  383 |     operator-(const _Tp& __x, const complex<_Tp>& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:383:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:460:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&)’
  460 |     operator-(const complex<_Tp>& __x)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:460:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/data/exact-penalty/pyver/src/TRModel.hpp:133:98: error: expected primary-expression before ‘)’ token
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                                                  ^
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘void TRModel::rebuildModel(const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/TRModel.hpp:153:51: error: ‘class TRModel’ has no member named ‘tr_center’; did you mean ‘trCenter’?
  153 |         pointsAbs.col(0).swap(pointsAbs.col(this->tr_center));
      |                                                   ^~~~~~~~~
      |                                                   trCenter
/data/exact-penalty/pyver/src/TRModel.hpp:154:45: error: ‘class TRModel’ has no member named ‘tr_center’; did you mean ‘trCenter’?
  154 |         std::swap(fvalues(0), fvalues(this->tr_center));
      |                                             ^~~~~~~~~
      |                                             trCenter
/data/exact-penalty/pyver/src/Helpers.hpp: In function ‘Eigen::VectorXd& unshiftPoint(Eigen::VectorXd&, const Eigen::VectorXd&, const Eigen::VectorXd&, const Eigen::VectorXd&)’:
/data/exact-penalty/pyver/src/Helpers.hpp:15:12: warning: reference to local variable ‘x_unshifted’ returned [-Wreturn-local-addr]
   15 |     return x_unshifted;
      |            ^~~~~~~~~~~
/data/exact-penalty/pyver/src/Helpers.hpp:14:21: note: declared here
   14 |     Eigen::VectorXd x_unshifted = (x + shift_center).cwiseMin(bu).cwiseMax(bl);
      |                     ^~~~~~~~~~~
/data/exact-penalty/pyver/src/Helpers.hpp: In function ‘std::pair<Eigen::Matrix<double, -1, 1>, bool> evaluate_new_fvalues(Function* const&, const Eigen::VectorXd&)’:
/data/exact-penalty/pyver/src/Helpers.hpp:19:31: error: request for member ‘size’ in ‘funcs’, which is of pointer type ‘const Functions’ {aka ‘Function* const’} (maybe you meant to use ‘->’ ?)
   19 |     int functions_num = funcs.size();
      |                               ^~~~
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘void TRModel::rebuildModel(const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/TRModel.hpp:153:51: error: ‘class TRModel’ has no member named ‘tr_center’; did you mean ‘trCenter’?
  153 |         pointsAbs.col(0).swap(pointsAbs.col(this->tr_center));
      |                                                   ^~~~~~~~~
      |                                                   trCenter
/data/exact-penalty/pyver/src/TRModel.hpp:154:45: error: ‘class TRModel’ has no member named ‘tr_center’; did you mean ‘trCenter’?
  154 |         std::swap(fvalues(0), fvalues(this->tr_center));
      |                                             ^~~~~~~~~
      |                                             trCenter
/data/exact-penalty/pyver/src/Helpers.hpp:24:36: error: no match for call to ‘(Function) (const Eigen::VectorXd&)’
   24 |             fvalues(nf) = funcs[nf](point);
      |                           ~~~~~~~~~^~~~~~~
In file included from /data/exact-penalty/pyver/src/pointWork.cpp:10:
/data/exact-penalty/pyver/src/Polynomials.hpp: In member function ‘Polynomial Polynomial::operator+(const Polynomial&) const’:
/data/exact-penalty/pyver/src/Polynomials.hpp:25:16: error: could not convert ‘result’ from ‘Eigen::VectorXd’ {aka ‘Eigen::Matrix<double, -1, 1>’} to ‘Polynomial’
   25 |         return result;
      |                ^~~~~~
      |                |
      |                Eigen::VectorXd {aka Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/Polynomials.hpp: In member function ‘Polynomial Polynomial::operator*(double) const’:
/data/exact-penalty/pyver/src/Polynomials.hpp:29:88: error: no matching function for call to ‘Polynomial::Polynomial(const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >)’
   29 |     Polynomial operator*(double scalar) const { return Polynomial(coefficients * scalar); }
      |                                                                                        ^
/data/exact-penalty/pyver/src/Polynomials.hpp:17:14: note: candidate: ‘Polynomial::Polynomial(const std::vector<double>&)’
   17 |     explicit Polynomial(const std::vector<double> &coeffs) : coefficients(coeffs) {}
      |              ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:17:52: note:   no known conversion for argument 1 from ‘const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >’ to ‘const std::vector<double>&’
   17 |     explicit Polynomial(const std::vector<double> &coeffs) : coefficients(coeffs) {}
      |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:16:5: note: candidate: ‘constexpr Polynomial::Polynomial()’
   16 |     Polynomial() = default;
      |     ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:16:5: note:   candidate expects 0 arguments, 1 provided
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note: candidate: ‘Polynomial::Polynomial(const Polynomial&)’
   10 | class Polynomial {
      |       ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note:   no known conversion for argument 1 from ‘const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >’ to ‘const Polynomial&’
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note: candidate: ‘constexpr Polynomial::Polynomial(Polynomial&&)’
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note:   no known conversion for argument 1 from ‘const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >’ to ‘Polynomial&&’
/data/exact-penalty/pyver/src/Polynomials.hpp: In static member function ‘static Polynomial Polynomial::Zero(int)’:
/data/exact-penalty/pyver/src/Polynomials.hpp:32:85: error: no matching function for call to ‘Polynomial::Polynomial(const Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::ConstantReturnType)’
   32 |     static Polynomial Zero(int size) { return Polynomial(Eigen::VectorXd::Zero(size)); }
      |                                                                                     ^
/data/exact-penalty/pyver/src/Polynomials.hpp:17:14: note: candidate: ‘Polynomial::Polynomial(const std::vector<double>&)’
   17 |     explicit Polynomial(const std::vector<double> &coeffs) : coefficients(coeffs) {}
      |              ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:17:52: note:   no known conversion for argument 1 from ‘const Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::ConstantReturnType’ {aka ‘const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >’} to ‘const std::vector<double>&’
   17 |     explicit Polynomial(const std::vector<double> &coeffs) : coefficients(coeffs) {}
      |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:16:5: note: candidate: ‘constexpr Polynomial::Polynomial()’
   16 |     Polynomial() = default;
      |     ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:16:5: note:   candidate expects 0 arguments, 1 provided
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note: candidate: ‘Polynomial::Polynomial(const Polynomial&)’
   10 | class Polynomial {
      |       ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note:   no known conversion for argument 1 from ‘const Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::ConstantReturnType’ {aka ‘const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >’} to ‘const Polynomial&’
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note: candidate: ‘constexpr Polynomial::Polynomial(Polynomial&&)’
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note:   no known conversion for argument 1 from ‘const Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::ConstantReturnType’ {aka ‘const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >’} to ‘Polynomial&&’
/data/exact-penalty/pyver/src/Polynomials.hpp: In member function ‘Polynomial Polynomial::zeroAtPoint(const Polynomial&, double) const’:
/data/exact-penalty/pyver/src/Polynomials.hpp:51:31: error: cannot convert ‘double’ to ‘const Eigen::VectorXd&’ {aka ‘const Eigen::Matrix<double, -1, 1>&’}
   51 |         double px  = evaluate(x);
      |                               ^
      |                               |
      |                               double
/data/exact-penalty/pyver/src/Polynomials.hpp:96:44: note:   initializing argument 1 of ‘double Polynomial::evaluate(const Eigen::VectorXd&) const’
   96 |     double evaluate(const Eigen::VectorXd &point) const {
      |                     ~~~~~~~~~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:52:34: error: cannot convert ‘double’ to ‘const Eigen::VectorXd&’ {aka ‘const Eigen::Matrix<double, -1, 1>&’}
   52 |         double p2x = p2.evaluate(x);
      |                                  ^
      |                                  |
      |                                  double
/data/exact-penalty/pyver/src/Polynomials.hpp:96:44: note:   initializing argument 1 of ‘double Polynomial::evaluate(const Eigen::VectorXd&) const’
   96 |     double evaluate(const Eigen::VectorXd &point) const {
      |                     ~~~~~~~~~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:59:43: error: passing ‘const Polynomial’ as ‘this’ argument discards qualifiers [-fpermissive]
   59 |             *this               = *this + p2Scaled;
      |                                           ^~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note:   in call to ‘constexpr Polynomial& Polynomial::operator=(Polynomial&&)’
   10 | class Polynomial {
      |       ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:60:44: error: cannot convert ‘double’ to ‘const Eigen::VectorXd&’ {aka ‘const Eigen::Matrix<double, -1, 1>&’}
   60 |             px                  = evaluate(x);
      |                                            ^
      |                                            |
      |                                            double
/data/exact-penalty/pyver/src/Polynomials.hpp:96:44: note:   initializing argument 1 of ‘double Polynomial::evaluate(const Eigen::VectorXd&) const’
   96 |     double evaluate(const Eigen::VectorXd &point) const {
      |                     ~~~~~~~~~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/TRModel.hpp:162:14: error: ‘iota’ is not a member of ‘std’
  162 |         std::iota(indices.begin(), indices.end(), 0);
      |              ^~~~
/data/exact-penalty/pyver/src/Polynomials.hpp: In member function ‘Polynomial Polynomial::orthogonalizeToOtherPolynomials(const std::vector<std::shared_ptr<Polynomial> >&, int, const Eigen::MatrixXd&, int)’:
/data/exact-penalty/pyver/src/Polynomials.hpp:71:59: error: ‘PolynomialPtr’ {aka ‘class std::shared_ptr<Polynomial>’} has no member named ‘zeroAtPoint’
   71 |             if (n != polyIndex) { polynomial = polynomial.zeroAtPoint(allPolynomials[n], points.col(n)); }
      |                                                           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:73:16: error: could not convert ‘polynomial’ from ‘PolynomialPtr’ {aka ‘std::shared_ptr<Polynomial>’} to ‘Polynomial’
   73 |         return polynomial;
      |                ^~~~~~~~~~
      |                |
      |                PolynomialPtr {aka std::shared_ptr<Polynomial>}
/data/exact-penalty/pyver/src/TRModel.hpp:174:52: error: ‘nfpBasis’ was not declared in this scope
  174 |         std::vector<Polynomial> pivotPolynomials = nfpBasis(dim); // Assuming nfpBasis is implemented
      |                                                    ^~~~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp:174:52: error: ‘nfpBasis’ was not declared in this scope
  174 |         std::vector<Polynomial> pivotPolynomials = nfpBasis(dim); // Assuming nfpBasis is implemented
      |                                                    ^~~~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp:184:17: error: ‘orthogonalizeToOtherPolynomials’ was not declared in this scope
  184 |                 orthogonalizeToOtherPolynomials(pivotPolynomials, i, newPointsShifted, lastPtIncluded);
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp:184:17: error: ‘orthogonalizeToOtherPolynomials’ was not declared in this scope
  184 |                 orthogonalizeToOtherPolynomials(pivotPolynomials, i, newPointsShifted, lastPtIncluded);
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp: In member function ‘std::tuple<Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, bool> Polynomial::maximizePolynomialAbs(const Eigen::VectorXd&, double, const Eigen::VectorXd&, const Eigen::VectorXd&)’:
/data/exact-penalty/pyver/src/Polynomials.hpp:124:39: error: ‘evaluatePolynomial’ was not declared in this scope
  124 |         double          pivotMin    = evaluatePolynomial(newPointMin);
      |                                       ^~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:132:34: error: ‘class Polynomial’ has no member named ‘evaluatePolynomial’
  132 |         pivotMax = polynomialMax.evaluatePolynomial(newPointMax);
      |                                  ^~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:164:31: error: expected primary-expression before ‘newPoints’
  164 |             newPoints = Eigen newPoints = Eigen::VectorXd(1);
      |                               ^~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp: In member function ‘std::vector<Polynomial> Polynomial::orthogonalizeBlock(const std::vector<Polynomial>&, const Eigen::VectorXd&, int, int)’:
/data/exact-penalty/pyver/src/Polynomials.hpp:184:84: error: cannot convert ‘const Eigen::VectorXd’ {aka ‘const Eigen::Matrix<double, -1, 1>’} to ‘double’
  184 |             if (p != orthEnd) { result[p] = result[p].zeroAtPoint(result[orthEnd], point); }
      |                                                                                    ^~~~~
      |                                                                                    |
      |                                                                                    const Eigen::VectorXd {aka const Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/Polynomials.hpp:50:57: note:   initializing argument 2 of ‘Polynomial Polynomial::zeroAtPoint(const Polynomial&, double) const’
   50 |     Polynomial zeroAtPoint(const Polynomial &p2, double x) const {
      |                                                  ~~~~~~~^
In file included from /data/exact-penalty/pyver/src/pointWork.cpp:11:
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘std::vector<double> TRModel::centerPoint() const’:
/data/exact-penalty/pyver/src/TRModel.hpp:49:38: error: could not convert ‘((const Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 0>*)(&((const TRModel*)this)->TRModel::pointsAbs))->Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 0>::operator[](((Eigen::Index)((size_t)((const TRModel*)this)->TRModel::trCenter)))’ from ‘const double’ to ‘std::vector<double>’
   49 |             return pointsAbs[trCenter];
      |                                      ^
      |                                      |
      |                                      const double
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘std::vector<double> TRModel::firstPoint() const’:
/data/exact-penalty/pyver/src/TRModel.hpp:58:31: error: could not convert ‘((const Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 0>*)(&((const TRModel*)this)->TRModel::pointsAbs))->Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 0>::operator[](0)’ from ‘const double’ to ‘std::vector<double>’
   58 |             return pointsAbs[0];
      |                               ^
      |                               |
      |                               const double
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘void TRModel::shiftPoints()’:
/data/exact-penalty/pyver/src/TRModel.hpp:78:71: error: ‘Eigen::MatrixXd’ {aka ‘class Eigen::Matrix<double, -1, -1>’} has no member named ‘push_back’
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                       ^~~~~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp:78:94: error: no match for ‘operator-’ (operand types are ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’} and ‘std::vector<double>’)
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_algobase.h:67,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/specfun.h:43,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/cmath:3699,
                 from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/Macros.h:714,
                 from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:19,
                 from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Dense:1,
                 from /data/exact-penalty/pyver/src/pointWork.cpp:1:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:625:5: note: candidate: ‘template<class _IteratorL, class _IteratorR> constexpr decltype ((__y.base() - __x.base())) std::operator-(const reverse_iterator<_IteratorL>&, const reverse_iterator<_IteratorR>&)’
  625 |     operator-(const reverse_iterator<_IteratorL>& __x,
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:625:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::reverse_iterator<_IteratorL>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:1800:5: note: candidate: ‘template<class _IteratorL, class _IteratorR> constexpr decltype ((__x.base() - __y.base())) std::operator-(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&)’
 1800 |     operator-(const move_iterator<_IteratorL>& __x,
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:1800:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::move_iterator<_IteratorL>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:48:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:365:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&, const complex<_Tp>&)’
  365 |     operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:365:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::complex<_Tp>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:374:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&, const _Tp&)’
  374 |     operator-(const complex<_Tp>& __x, const _Tp& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:374:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::complex<_Tp>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:383:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const _Tp&, const complex<_Tp>&)’
  383 |     operator-(const _Tp& __x, const complex<_Tp>& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:383:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:460:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&)’
  460 |     operator-(const complex<_Tp>& __x)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:460:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:78:96: note:   mismatched types ‘const std::complex<_Tp>’ and ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’}
   78 |         for (size_t i = 0; i < pointsAbs.size(); ++i) { pointsShifted.push_back(pointsAbs[i] - center); }
      |                                                                                                ^~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘void TRModel::updatePoint(size_t, Eigen::VectorXd&, Eigen::VectorXd)’:
/data/exact-penalty/pyver/src/TRModel.hpp:94:32: error: cannot convert ‘Eigen::VectorXd’ {aka ‘Eigen::Matrix<double, -1, 1>’} to ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, -1>, 1>::Scalar’ {aka ‘double’} in assignment
   94 |             pointsAbs[index] = point;
      |                                ^~~~~
      |                                |
      |                                Eigen::VectorXd {aka Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/TRModel.hpp:95:32: error: cannot convert ‘Eigen::VectorXd’ {aka ‘Eigen::Matrix<double, -1, 1>’} to ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, 1>, 1>::Scalar’ {aka ‘double’} in assignment
   95 |             fValues[index]   = fValue;
      |                                ^~~~~~
      |                                |
      |                                Eigen::VectorXd {aka Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/TRModel.hpp:96:25: error: cannot convert ‘Eigen::VectorXd’ {aka ‘Eigen::Matrix<double, -1, 1>’} to ‘const std::vector<double>&’
   96 |             updateCache(point, fValue);
      |                         ^~~~~
      |                         |
      |                         Eigen::VectorXd {aka Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/TRModel.hpp:82:49: note:   initializing argument 1 of ‘void TRModel::updateCache(const std::vector<double>&, double)’
   82 |     void updateCache(const std::vector<double> &point, double fValue) {
      |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘bool TRModel::isLambdaPoised(const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/TRModel.hpp:107:33: error: invalid operands of types ‘const std::map<std::__cxx11::basic_string<char>, double>::mapped_type’ {aka ‘const double’} and ‘const char [6]’ to binary ‘operator==’
  107 |         if (options.at("basis") == "dummy") {
      |             ~~~~~~~~~~~~~~~~~~~ ^~ ~~~~~~~
      |                       |            |
      |                       |            const char [6]
      |                       const std::map<std::__cxx11::basic_string<char>, double>::mapped_type {aka const double}
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘bool TRModel::isComplete()’:
/data/exact-penalty/pyver/src/TRModel.hpp:122:36: error: ‘class TRModel’ has no member named ‘pivotPolynomial’; did you mean ‘pivotPolynomials’?
  122 |         int maxTermsUnused = this->pivotPolynomial.size();
      |                                    ^~~~~~~~~~~~~~~
      |                                    pivotPolynomials
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘bool TRModel::isOld(const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/TRModel.hpp:133:51: error: no match for ‘operator-’ (operand types are ‘std::vector<double>’ and ‘std::vector<double>’)
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                ~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~
      |                                                |                     |
      |                                                vector<[...]>         vector<[...]>
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:625:5: note: candidate: ‘template<class _IteratorL, class _IteratorR> constexpr decltype ((__y.base() - __x.base())) std::operator-(const reverse_iterator<_IteratorL>&, const reverse_iterator<_IteratorR>&)’
  625 |     operator-(const reverse_iterator<_IteratorL>& __x,
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:625:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::reverse_iterator<_IteratorL>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:1800:5: note: candidate: ‘template<class _IteratorL, class _IteratorR> constexpr decltype ((__x.base() - __y.base())) std::operator-(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&)’
 1800 |     operator-(const move_iterator<_IteratorL>& __x,
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_iterator.h:1800:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::move_iterator<_IteratorL>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:365:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&, const complex<_Tp>&)’
  365 |     operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:365:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:374:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&, const _Tp&)’
  374 |     operator-(const complex<_Tp>& __x, const _Tp& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:374:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:383:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const _Tp&, const complex<_Tp>&)’
  383 |     operator-(const _Tp& __x, const complex<_Tp>& __y)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:383:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:460:5: note: candidate: ‘template<class _Tp> constexpr std::complex<_Tp> std::operator-(const complex<_Tp>&)’
  460 |     operator-(const complex<_Tp>& __x)
      |     ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/complex:460:5: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/TRModel.hpp:133:71: note:   ‘std::vector<double>’ is not derived from ‘const std::complex<_Tp>’
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                       ^
/data/exact-penalty/pyver/src/TRModel.hpp:133:98: error: expected primary-expression before ‘)’ token
  133 |         double distance     = (this->firstPoint() - this->centerPoint()).lpNorm<Eigen::Infinity>();
      |                                                                                                  ^
/data/exact-penalty/pyver/src/TRModel.hpp:190:30: error: ‘evaluatePolynomial’ was not declared in this scope
  190 |                 double val = evaluatePolynomial(pivotPolynomials[i], newPointsShifted.col(j));
      |                              ^~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp:190:30: error: ‘evaluatePolynomial’ was not declared in this scope
  190 |                 double val = evaluatePolynomial(pivotPolynomials[i], newPointsShifted.col(j));
      |                              ^~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘void TRModel::rebuildModel(const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/TRModel.hpp:153:51: error: ‘class TRModel’ has no member named ‘tr_center’; did you mean ‘trCenter’?
  153 |         pointsAbs.col(0).swap(pointsAbs.col(this->tr_center));
      |                                                   ^~~~~~~~~
      |                                                   trCenter
/data/exact-penalty/pyver/src/TRModel.hpp:154:45: error: ‘class TRModel’ has no member named ‘tr_center’; did you mean ‘trCenter’?
  154 |         std::swap(fvalues(0), fvalues(this->tr_center));
      |                                             ^~~~~~~~~
      |                                             trCenter
/data/exact-penalty/pyver/src/TRModel.hpp:212:34: error: no match for ‘operator=’ (operand types are ‘std::vector<std::shared_ptr<Polynomial> >’ and ‘std::vector<Polynomial>’)
  212 |         this->pivotPolynomials = pivotPolynomials;
      |                                  ^~~~~~~~~~~~~~~~
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/vector:72,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/functional:64,
                 from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:82:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/vector.tcc:210:5: note: candidate: ‘constexpr std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(const std::vector<_Tp, _Alloc>&) [with _Tp = std::shared_ptr<Polynomial>; _Alloc = std::allocator<std::shared_ptr<Polynomial> >]’
  210 |     vector<_Tp, _Alloc>::
      |     ^~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/vector.tcc:211:42: note:   no known conversion for argument 1 from ‘std::vector<Polynomial>’ to ‘const std::vector<std::shared_ptr<Polynomial> >&’
  211 |     operator=(const vector<_Tp, _Alloc>& __x)
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/vector:66:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:766:7: note: candidate: ‘constexpr std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(std::vector<_Tp, _Alloc>&&) [with _Tp = std::shared_ptr<Polynomial>; _Alloc = std::allocator<std::shared_ptr<Polynomial> >]’
  766 |       operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      |       ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:766:26: note:   no known conversion for argument 1 from ‘std::vector<Polynomial>’ to ‘std::vector<std::shared_ptr<Polynomial> >&&’
  766 |       operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      |                 ~~~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:788:7: note: candidate: ‘constexpr std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(std::initializer_list<_Tp>) [with _Tp = std::shared_ptr<Polynomial>; _Alloc = std::allocator<std::shared_ptr<Polynomial> >]’
  788 |       operator=(initializer_list<value_type> __l)
      |       ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:788:46: note:   no known conversion for argument 1 from ‘std::vector<Polynomial>’ to ‘std::initializer_list<std::shared_ptr<Polynomial> >’
  788 |       operator=(initializer_list<value_type> __l)
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h: In instantiation of ‘constexpr std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::size() const [with _Tp = Polynomial; _Alloc = std::allocator<Polynomial>; size_type = long unsigned int]’:
/data/exact-penalty/pyver/src/TRModel.hpp:175:66:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:993:50: error: invalid use of incomplete type ‘class Polynomial’
  993 |       { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
In file included from /data/exact-penalty/pyver/src/main.cpp:8:
/data/exact-penalty/pyver/src/Definitions.hpp:20:7: note: forward declaration of ‘class Polynomial’
   20 | class Polynomial;
      |       ^~~~~~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp:212:34: error: no match for ‘operator=’ (operand types are ‘std::vector<std::shared_ptr<Polynomial> >’ and ‘std::vector<Polynomial>’)
  212 |         this->pivotPolynomials = pivotPolynomials;
      |                                  ^~~~~~~~~~~~~~~~
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/vector:72,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/functional:64,
                 from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:82:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/vector.tcc:210:5: note: candidate: ‘constexpr std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(const std::vector<_Tp, _Alloc>&) [with _Tp = std::shared_ptr<Polynomial>; _Alloc = std::allocator<std::shared_ptr<Polynomial> >]’
  210 |     vector<_Tp, _Alloc>::
      |     ^~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/vector.tcc:211:42: note:   no known conversion for argument 1 from ‘std::vector<Polynomial>’ to ‘const std::vector<std::shared_ptr<Polynomial> >&’
  211 |     operator=(const vector<_Tp, _Alloc>& __x)
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/vector:66:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:766:7: note: candidate: ‘constexpr std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(std::vector<_Tp, _Alloc>&&) [with _Tp = std::shared_ptr<Polynomial>; _Alloc = std::allocator<std::shared_ptr<Polynomial> >]’
  766 |       operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      |       ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:766:26: note:   no known conversion for argument 1 from ‘std::vector<Polynomial>’ to ‘std::vector<std::shared_ptr<Polynomial> >&&’
  766 |       operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      |                 ~~~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:788:7: note: candidate: ‘constexpr std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(std::initializer_list<_Tp>) [with _Tp = std::shared_ptr<Polynomial>; _Alloc = std::allocator<std::shared_ptr<Polynomial> >]’
  788 |       operator=(initializer_list<value_type> __l)
      |       ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:788:46: note:   no known conversion for argument 1 from ‘std::vector<Polynomial>’ to ‘std::initializer_list<std::shared_ptr<Polynomial> >’
  788 |       operator=(initializer_list<value_type> __l)
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h: In instantiation of ‘constexpr std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::size() const [with _Tp = Polynomial; _Alloc = std::allocator<Polynomial>; size_type = long unsigned int]’:
/data/exact-penalty/pyver/src/TRModel.hpp:175:66:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:993:50: error: invalid use of incomplete type ‘class Polynomial’
  993 |       { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
In file included from /data/exact-penalty/pyver/src/Aux.cpp:11:
/data/exact-penalty/pyver/src/Definitions.hpp:20:7: note: forward declaration of ‘class Polynomial’
   20 | class Polynomial;
      |       ^~~~~~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp:162:14: error: ‘iota’ is not a member of ‘std’
  162 |         std::iota(indices.begin(), indices.end(), 0);
      |              ^~~~
/data/exact-penalty/pyver/src/TRModel.hpp:174:52: error: ‘nfpBasis’ was not declared in this scope
  174 |         std::vector<Polynomial> pivotPolynomials = nfpBasis(dim); // Assuming nfpBasis is implemented
      |                                                    ^~~~~~~~
In file included from /data/exact-penalty/pyver/src/Aux.cpp:14:
/data/exact-penalty/pyver/src/Polynomials.hpp: In member function ‘Polynomial Polynomial::operator+(const Polynomial&) const’:
/data/exact-penalty/pyver/src/Polynomials.hpp:25:16: error: could not convert ‘result’ from ‘Eigen::VectorXd’ {aka ‘Eigen::Matrix<double, -1, 1>’} to ‘Polynomial’
   25 |         return result;
      |                ^~~~~~
      |                |
      |                Eigen::VectorXd {aka Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/Polynomials.hpp: In member function ‘Polynomial Polynomial::operator*(double) const’:
/data/exact-penalty/pyver/src/Polynomials.hpp:29:88: error: no matching function for call to ‘Polynomial::Polynomial(const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >)’
   29 |     Polynomial operator*(double scalar) const { return Polynomial(coefficients * scalar); }
      |                                                                                        ^
/data/exact-penalty/pyver/src/Polynomials.hpp:17:14: note: candidate: ‘Polynomial::Polynomial(const std::vector<double>&)’
   17 |     explicit Polynomial(const std::vector<double> &coeffs) : coefficients(coeffs) {}
      |              ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:17:52: note:   no known conversion for argument 1 from ‘const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >’ to ‘const std::vector<double>&’
   17 |     explicit Polynomial(const std::vector<double> &coeffs) : coefficients(coeffs) {}
      |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:16:5: note: candidate: ‘constexpr Polynomial::Polynomial()’
   16 |     Polynomial() = default;
      |     ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:16:5: note:   candidate expects 0 arguments, 1 provided
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note: candidate: ‘Polynomial::Polynomial(const Polynomial&)’
   10 | class Polynomial {
      |       ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note:   no known conversion for argument 1 from ‘const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >’ to ‘const Polynomial&’
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note: candidate: ‘constexpr Polynomial::Polynomial(Polynomial&&)’
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note:   no known conversion for argument 1 from ‘const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >’ to ‘Polynomial&&’
/data/exact-penalty/pyver/src/Polynomials.hpp: In static member function ‘static Polynomial Polynomial::Zero(int)’:
/data/exact-penalty/pyver/src/Polynomials.hpp:32:85: error: no matching function for call to ‘Polynomial::Polynomial(const Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::ConstantReturnType)’
   32 |     static Polynomial Zero(int size) { return Polynomial(Eigen::VectorXd::Zero(size)); }
      |                                                                                     ^
/data/exact-penalty/pyver/src/Polynomials.hpp:17:14: note: candidate: ‘Polynomial::Polynomial(const std::vector<double>&)’
   17 |     explicit Polynomial(const std::vector<double> &coeffs) : coefficients(coeffs) {}
      |              ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:17:52: note:   no known conversion for argument 1 from ‘const Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::ConstantReturnType’ {aka ‘const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >’} to ‘const std::vector<double>&’
   17 |     explicit Polynomial(const std::vector<double> &coeffs) : coefficients(coeffs) {}
      |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:16:5: note: candidate: ‘constexpr Polynomial::Polynomial()’
   16 |     Polynomial() = default;
      |     ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:16:5: note:   candidate expects 0 arguments, 1 provided
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note: candidate: ‘Polynomial::Polynomial(const Polynomial&)’
   10 | class Polynomial {
      |       ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note:   no known conversion for argument 1 from ‘const Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::ConstantReturnType’ {aka ‘const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >’} to ‘const Polynomial&’
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note: candidate: ‘constexpr Polynomial::Polynomial(Polynomial&&)’
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note:   no known conversion for argument 1 from ‘const Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::ConstantReturnType’ {aka ‘const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >’} to ‘Polynomial&&’
/data/exact-penalty/pyver/src/Polynomials.hpp: In member function ‘Polynomial Polynomial::zeroAtPoint(const Polynomial&, double) const’:
/data/exact-penalty/pyver/src/Polynomials.hpp:51:31: error: cannot convert ‘double’ to ‘const Eigen::VectorXd&’ {aka ‘const Eigen::Matrix<double, -1, 1>&’}
   51 |         double px  = evaluate(x);
      |                               ^
      |                               |
      |                               double
/data/exact-penalty/pyver/src/Polynomials.hpp:96:44: note:   initializing argument 1 of ‘double Polynomial::evaluate(const Eigen::VectorXd&) const’
   96 |     double evaluate(const Eigen::VectorXd &point) const {
      |                     ~~~~~~~~~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:52:34: error: cannot convert ‘double’ to ‘const Eigen::VectorXd&’ {aka ‘const Eigen::Matrix<double, -1, 1>&’}
   52 |         double p2x = p2.evaluate(x);
      |                                  ^
      |                                  |
      |                                  double
/data/exact-penalty/pyver/src/Polynomials.hpp:96:44: note:   initializing argument 1 of ‘double Polynomial::evaluate(const Eigen::VectorXd&) const’
   96 |     double evaluate(const Eigen::VectorXd &point) const {
      |                     ~~~~~~~~~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:59:43: error: passing ‘const Polynomial’ as ‘this’ argument discards qualifiers [-fpermissive]
   59 |             *this               = *this + p2Scaled;
      |                                           ^~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:10:7: note:   in call to ‘constexpr Polynomial& Polynomial::operator=(Polynomial&&)’
   10 | class Polynomial {
      |       ^~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:60:44: error: cannot convert ‘double’ to ‘const Eigen::VectorXd&’ {aka ‘const Eigen::Matrix<double, -1, 1>&’}
   60 |             px                  = evaluate(x);
      |                                            ^
      |                                            |
      |                                            double
/data/exact-penalty/pyver/src/Polynomials.hpp:96:44: note:   initializing argument 1 of ‘double Polynomial::evaluate(const Eigen::VectorXd&) const’
   96 |     double evaluate(const Eigen::VectorXd &point) const {
      |                     ~~~~~~~~~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp: In member function ‘Polynomial Polynomial::orthogonalizeToOtherPolynomials(const std::vector<std::shared_ptr<Polynomial> >&, int, const Eigen::MatrixXd&, int)’:
/data/exact-penalty/pyver/src/Polynomials.hpp:71:59: error: ‘PolynomialPtr’ {aka ‘class std::shared_ptr<Polynomial>’} has no member named ‘zeroAtPoint’
   71 |             if (n != polyIndex) { polynomial = polynomial.zeroAtPoint(allPolynomials[n], points.col(n)); }
      |                                                           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:73:16: error: could not convert ‘polynomial’ from ‘PolynomialPtr’ {aka ‘std::shared_ptr<Polynomial>’} to ‘Polynomial’
   73 |         return polynomial;
      |                ^~~~~~~~~~
      |                |
      |                PolynomialPtr {aka std::shared_ptr<Polynomial>}
/data/exact-penalty/pyver/src/TRModel.hpp:184:17: error: ‘orthogonalizeToOtherPolynomials’ was not declared in this scope
  184 |                 orthogonalizeToOtherPolynomials(pivotPolynomials, i, newPointsShifted, lastPtIncluded);
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:314:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: error: no matching function for call to ‘Eigen::Matrix<double, -1, -1>::_init1<std::vector<std::vector<double, std::allocator<double> >, std::allocator<std::vector<double, std::allocator<double> > > > >(const std::vector<std::vector<double> >&)’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:313:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:807:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(Eigen::Index, std::enable_if_t<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T>*) [with T = std::vector<std::vector<double> >; Derived = Eigen::Matrix<double, -1, -1>; Eigen::Index = long int; std::enable_if_t<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T> = std::vector<std::vector<double> >; typename Eigen::internal::dense_xpr_base<Derived>::type = Eigen::MatrixBase<Eigen::Matrix<double, -1, -1> >; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr; typename Eigen::internal::traits<T>::Scalar = double; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr]’
  807 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:808:13: note:   no known conversion for argument 1 from ‘const std::vector<std::vector<double> >’ to ‘Eigen::Index’ {aka ‘long int’}
  808 |       Index size,
      |       ~~~~~~^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Scalar&, std::enable_if_t<((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T>*) [with Derived = Eigen::Matrix<double, -1, -1>]’
  823 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46: note:   template argument deduction/substitution failed:
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/move.h:37,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/exception_ptr.h:41,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/exception:164,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/ios:41:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = std::vector<std::vector<double> >]’:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46:   required by substitution of ‘template<class T> void Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::_init1(const Scalar&, std::enable_if_t<((Eigen::MatrixBase<Eigen::Matrix<double, -1, -1> >::SizeAtCompileTime == 1) && std::is_convertible<T, double>::value), T>*) [with T = std::vector<std::vector<double> >]’
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29:   required from ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:2610:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::vector<std::vector<double> > >’
 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
      |           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::Index&, std::enable_if_t<((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T*>*) [with Derived = Eigen::Matrix<double, -1, -1>]’
  833 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46: note:   template argument deduction/substitution failed:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = std::vector<std::vector<double> >*]’:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46:   required by substitution of ‘template<class T> void Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::_init1(const Eigen::Index&, std::enable_if_t<((((! Eigen::internal::is_same<long int, double>::value) && Eigen::internal::is_same<long int, T>::value) && (Eigen::MatrixBase<Eigen::Matrix<double, -1, -1> >::SizeAtCompileTime == 1)) && std::is_convertible<T, double>::value), T*>*) [with T = std::vector<std::vector<double> >]’
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29:   required from ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:2610:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::vector<std::vector<double> >*>’
 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
      |           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:844:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(const Scalar*) [with T = std::vector<std::vector<double> >; Derived = Eigen::Matrix<double, -1, -1>; Scalar = double]’
  844 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Scalar* data) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:844:67: note:   no known conversion for argument 1 from ‘const std::vector<std::vector<double> >’ to ‘const Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::Scalar*’ {aka ‘const double*’}
  844 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Scalar* data) {
      |                                                     ~~~~~~~~~~~~~~^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:850:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, -1>]’
  850 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const DenseBase<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:850:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<std::vector<double> >’ is not derived from ‘const Eigen::DenseBase<Derived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:856:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(const Derived&) [with T = std::vector<std::vector<double> >; Derived = Eigen::Matrix<double, -1, -1>]’
  856 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Derived& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:856:68: note:   no known conversion for argument 1 from ‘const std::vector<std::vector<double> >’ to ‘const Eigen::Matrix<double, -1, -1>&’
  856 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Derived& other) {
      |                                                     ~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:862:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, -1>]’
  862 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const EigenBase<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:862:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<std::vector<double> >’ is not derived from ‘const Eigen::EigenBase<OtherDerived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:867:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, -1>]’
  867 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const ReturnByValue<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:867:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<std::vector<double> >’ is not derived from ‘const Eigen::ReturnByValue<OtherDerived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:873:46: note: candidate: ‘template<class T, class OtherDerived, int ColsAtCompileTime> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>&) [with OtherDerived = T; int ColsAtCompileTime = OtherDerived; Derived = Eigen::Matrix<double, -1, -1>]’
  873 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const RotationBase<OtherDerived, ColsAtCompileTime>& r) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:873:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<std::vector<double> >’ is not derived from ‘const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:879:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Scalar&, std::enable_if_t<((((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T>*) [with Derived = Eigen::Matrix<double, -1, -1>]’
  879 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:879:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:890:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::Index&, std::enable_if_t<((((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic)) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T*>*) [with Derived = Eigen::Matrix<double, -1, -1>]’
  890 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:890:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:30:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: error: no matching function for call to ‘Eigen::Matrix<double, -1, 1>::_init1<std::vector<double, std::allocator<double> > >(const std::vector<double>&)’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:807:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(Eigen::Index, std::enable_if_t<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T>*) [with T = std::vector<double>; Derived = Eigen::Matrix<double, -1, 1>; Eigen::Index = long int; std::enable_if_t<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T> = std::vector<double>; typename Eigen::internal::dense_xpr_base<Derived>::type = Eigen::MatrixBase<Eigen::Matrix<double, -1, 1> >; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr; typename Eigen::internal::traits<T>::Scalar = double; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr]’
  807 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:808:13: note:   no known conversion for argument 1 from ‘const std::vector<double>’ to ‘Eigen::Index’ {aka ‘long int’}
  808 |       Index size,
      |       ~~~~~~^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Scalar&, std::enable_if_t<((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T>*) [with Derived = Eigen::Matrix<double, -1, 1>]’
  823 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46: note:   template argument deduction/substitution failed:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = std::vector<double>]’:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46:   required by substitution of ‘template<class T> void Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 1> >::_init1(const Scalar&, std::enable_if_t<((Eigen::MatrixBase<Eigen::Matrix<double, -1, 1> >::SizeAtCompileTime == 1) && std::is_convertible<T, double>::value), T>*) [with T = std::vector<double>]’
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29:   required from ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’
/data/exact-penalty/pyver/src/TRModel.hpp:31:30:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:2610:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::vector<double> >’
 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
      |           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:30:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::Index&, std::enable_if_t<((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T*>*) [with Derived = Eigen::Matrix<double, -1, 1>]’
  833 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46: note:   template argument deduction/substitution failed:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = std::vector<double>*]’:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46:   required by substitution of ‘template<class T> void Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 1> >::_init1(const Eigen::Index&, std::enable_if_t<((((! Eigen::internal::is_same<long int, double>::value) && Eigen::internal::is_same<long int, T>::value) && (Eigen::MatrixBase<Eigen::Matrix<double, -1, 1> >::SizeAtCompileTime == 1)) && std::is_convertible<T, double>::value), T*>*) [with T = std::vector<double>]’
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29:   required from ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’
/data/exact-penalty/pyver/src/TRModel.hpp:31:30:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:2610:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::vector<double>*>’
 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
      |           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:30:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:844:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(const Scalar*) [with T = std::vector<double>; Derived = Eigen::Matrix<double, -1, 1>; Scalar = double]’
  844 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Scalar* data) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:844:67: note:   no known conversion for argument 1 from ‘const std::vector<double>’ to ‘const Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 1> >::Scalar*’ {aka ‘const double*’}
  844 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Scalar* data) {
      |                                                     ~~~~~~~~~~~~~~^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:850:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, 1>]’
  850 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const DenseBase<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:850:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<double>’ is not derived from ‘const Eigen::DenseBase<Derived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:856:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(const Derived&) [with T = std::vector<double>; Derived = Eigen::Matrix<double, -1, 1>]’
  856 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Derived& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:856:68: note:   no known conversion for argument 1 from ‘const std::vector<double>’ to ‘const Eigen::Matrix<double, -1, 1>&’
  856 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Derived& other) {
      |                                                     ~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:862:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, 1>]’
  862 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const EigenBase<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:862:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<double>’ is not derived from ‘const Eigen::EigenBase<OtherDerived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:867:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, 1>]’
  867 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const ReturnByValue<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:867:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<double>’ is not derived from ‘const Eigen::ReturnByValue<OtherDerived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:873:46: note: candidate: ‘template<class T, class OtherDerived, int ColsAtCompileTime> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>&) [with OtherDerived = T; int ColsAtCompileTime = OtherDerived; Derived = Eigen::Matrix<double, -1, 1>]’
  873 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const RotationBase<OtherDerived, ColsAtCompileTime>& r) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:873:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<double>’ is not derived from ‘const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:879:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Scalar&, std::enable_if_t<((((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T>*) [with Derived = Eigen::Matrix<double, -1, 1>]’
  879 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:879:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:890:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::Index&, std::enable_if_t<((((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic)) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T*>*) [with Derived = Eigen::Matrix<double, -1, 1>]’
  890 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:890:46: note:   template argument deduction/substitution failed:
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:170:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h: In instantiation of ‘Eigen::DenseCoeffsBase<Derived, 0>::CoeffReturnType Eigen::DenseCoeffsBase<Derived, 0>::operator[](Eigen::Index) const [with Derived = Eigen::Matrix<double, -1, -1>; CoeffReturnType = const double&; Eigen::Index = long int]’:
/data/exact-penalty/pyver/src/TRModel.hpp:49:38:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h:141:34: error: static assertion failed: THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD
  141 |     EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
      |                                  ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h:141:34: note: ‘Eigen::Matrix<double, -1, -1>::IsVectorAtCompileTime’ evaluates to false
  141 |     EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
      |                                  ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/TRModel.hpp:190:30: error: ‘evaluatePolynomial’ was not declared in this scope
  190 |                 double val = evaluatePolynomial(pivotPolynomials[i], newPointsShifted.col(j));
      |                              ^~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h: In instantiation of ‘constexpr void Eigen::PlainObjectBase<Derived>::resize(Eigen::Index) [with Derived = Eigen::Matrix<double, -1, -1>; Eigen::Index = long int]’:
/data/exact-penalty/pyver/src/TRModel.hpp:76:29:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:37:29: error: static assertion failed: YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX
   37 |   EIGEN_STATIC_ASSERT(TYPE::IsVectorAtCompileTime, YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX)
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:328:5: note: in expansion of macro ‘EIGEN_STATIC_ASSERT_VECTOR_ONLY’
  328 |     EIGEN_STATIC_ASSERT_VECTOR_ONLY(PlainObjectBase)
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:37:29: note: ‘Eigen::DenseBase<Eigen::Matrix<double, -1, -1> >::IsVectorAtCompileTime’ evaluates to false
   37 |   EIGEN_STATIC_ASSERT(TYPE::IsVectorAtCompileTime, YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX)
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:328:5: note: in expansion of macro ‘EIGEN_STATIC_ASSERT_VECTOR_ONLY’
  328 |     EIGEN_STATIC_ASSERT_VECTOR_ONLY(PlainObjectBase)
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h: In instantiation of ‘Eigen::DenseCoeffsBase<Derived, 1>::Scalar& Eigen::DenseCoeffsBase<Derived, 1>::operator[](Eigen::Index) [with Derived = Eigen::Matrix<double, -1, -1>; Scalar = double; Eigen::Index = long int]’:
/data/exact-penalty/pyver/src/TRModel.hpp:78:92:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h:349:34: error: static assertion failed: THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD
  349 |     EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
      |                                  ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h:349:34: note: ‘Eigen::Matrix<double, -1, -1>::IsVectorAtCompileTime’ evaluates to false
  349 |     EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
      |                                  ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h: In instantiation of ‘constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](size_type) [with _Tp = Polynomial; _Alloc = std::allocator<Polynomial>; reference = Polynomial&; size_type = long unsigned int]’:
/data/exact-penalty/pyver/src/TRModel.hpp:183:31:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:1129:41: error: invalid use of incomplete type ‘class Polynomial’
 1129 |         return *(this->_M_impl._M_start + __n);
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
/data/exact-penalty/pyver/src/Definitions.hpp:20:7: note: forward declaration of ‘class Polynomial’
   20 | class Polynomial;
      |       ^~~~~~~~~~
/data/exact-penalty/pyver/src/TRModel.hpp:212:34: error: no match for ‘operator=’ (operand types are ‘std::vector<std::shared_ptr<Polynomial> >’ and ‘std::vector<Polynomial>’)
  212 |         this->pivotPolynomials = pivotPolynomials;
      |                                  ^~~~~~~~~~~~~~~~
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/vector:72,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/functional:64,
                 from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:82:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/vector.tcc:210:5: note: candidate: ‘constexpr std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(const std::vector<_Tp, _Alloc>&) [with _Tp = std::shared_ptr<Polynomial>; _Alloc = std::allocator<std::shared_ptr<Polynomial> >]’
  210 |     vector<_Tp, _Alloc>::
      |     ^~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/vector.tcc:211:42: note:   no known conversion for argument 1 from ‘std::vector<Polynomial>’ to ‘const std::vector<std::shared_ptr<Polynomial> >&’
  211 |     operator=(const vector<_Tp, _Alloc>& __x)
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/vector:66:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:766:7: note: candidate: ‘constexpr std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(std::vector<_Tp, _Alloc>&&) [with _Tp = std::shared_ptr<Polynomial>; _Alloc = std::allocator<std::shared_ptr<Polynomial> >]’
  766 |       operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      |       ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:766:26: note:   no known conversion for argument 1 from ‘std::vector<Polynomial>’ to ‘std::vector<std::shared_ptr<Polynomial> >&&’
  766 |       operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      |                 ~~~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:788:7: note: candidate: ‘constexpr std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(std::initializer_list<_Tp>) [with _Tp = std::shared_ptr<Polynomial>; _Alloc = std::allocator<std::shared_ptr<Polynomial> >]’
  788 |       operator=(initializer_list<value_type> __l)
      |       ^~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:788:46: note:   no known conversion for argument 1 from ‘std::vector<Polynomial>’ to ‘std::initializer_list<std::shared_ptr<Polynomial> >’
  788 |       operator=(initializer_list<value_type> __l)
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/Polynomials.hpp: In member function ‘std::tuple<Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, bool> Polynomial::maximizePolynomialAbs(const Eigen::VectorXd&, double, const Eigen::VectorXd&, const Eigen::VectorXd&)’:
/data/exact-penalty/pyver/src/Polynomials.hpp:124:39: error: ‘evaluatePolynomial’ was not declared in this scope
  124 |         double          pivotMin    = evaluatePolynomial(newPointMin);
      |                                       ^~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:132:34: error: ‘class Polynomial’ has no member named ‘evaluatePolynomial’
  132 |         pivotMax = polynomialMax.evaluatePolynomial(newPointMax);
      |                                  ^~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:164:31: error: expected primary-expression before ‘newPoints’
  164 |             newPoints = Eigen newPoints = Eigen::VectorXd(1);
      |                               ^~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp: In member function ‘std::vector<Polynomial> Polynomial::orthogonalizeBlock(const std::vector<Polynomial>&, const Eigen::VectorXd&, int, int)’:
/data/exact-penalty/pyver/src/Polynomials.hpp:184:84: error: cannot convert ‘const Eigen::VectorXd’ {aka ‘const Eigen::Matrix<double, -1, 1>’} to ‘double’
  184 |             if (p != orthEnd) { result[p] = result[p].zeroAtPoint(result[orthEnd], point); }
      |                                                                                    ^~~~~
      |                                                                                    |
      |                                                                                    const Eigen::VectorXd {aka const Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/Polynomials.hpp:50:57: note:   initializing argument 2 of ‘Polynomial Polynomial::zeroAtPoint(const Polynomial&, double) const’
   50 |     Polynomial zeroAtPoint(const Polynomial &p2, double x) const {
      |                                                  ~~~~~~~^
In file included from /data/exact-penalty/pyver/src/Aux.cpp:15:
/data/exact-penalty/pyver/src/Helpers.hpp: In function ‘Eigen::VectorXd& shiftPoint(Eigen::VectorXd&, const Eigen::VectorXd&)’:
/data/exact-penalty/pyver/src/Helpers.hpp:7:12: warning: reference to local variable ‘x_shifted’ returned [-Wreturn-local-addr]
    7 |     return x_shifted;
      |            ^~~~~~~~~
/data/exact-penalty/pyver/src/Helpers.hpp:6:21: note: declared here
    6 |     Eigen::VectorXd x_shifted = x - shift_center;
      |                     ^~~~~~~~~
/data/exact-penalty/pyver/src/Helpers.hpp: In function ‘Eigen::VectorXd& unshiftPoint(Eigen::VectorXd&, const Eigen::VectorXd&, const Eigen::VectorXd&, const Eigen::VectorXd&)’:
/data/exact-penalty/pyver/src/Helpers.hpp:15:12: warning: reference to local variable ‘x_unshifted’ returned [-Wreturn-local-addr]
   15 |     return x_unshifted;
      |            ^~~~~~~~~~~
/data/exact-penalty/pyver/src/Helpers.hpp:14:21: note: declared here
   14 |     Eigen::VectorXd x_unshifted = (x + shift_center).cwiseMin(bu).cwiseMax(bl);
      |                     ^~~~~~~~~~~
/data/exact-penalty/pyver/src/pointWork.cpp: In function ‘std::pair<std::shared_ptr<TRModel>, bool> addPoint(TRModelPtr&, const Eigen::VectorXd&, const Eigen::VectorXd&, double)’:
/data/exact-penalty/pyver/src/pointWork.cpp:45:9: error: expected primary-expression before ‘,’ token
   45 |         , newPointShifted, model->radius, model->blShifted, model->buShifted, shiftCenter);
      |         ^
/data/exact-penalty/pyver/src/pointWork.cpp:45:50: error: ‘using std::__shared_ptr_access<TRModel, __gnu_cxx::_S_atomic, false, false>::element_type = class TRModel’ {aka ‘class TRModel’} has no member named ‘blShifted’
   45 |         , newPointShifted, model->radius, model->blShifted, model->buShifted, shiftCenter);
      |                                                  ^~~~~~~~~
/data/exact-penalty/pyver/src/pointWork.cpp:45:68: error: ‘using std::__shared_ptr_access<TRModel, __gnu_cxx::_S_atomic, false, false>::element_type = class TRModel’ {aka ‘class TRModel’} has no member named ‘buShifted’
   45 |         , newPointShifted, model->radius, model->blShifted, model->buShifted, shiftCenter);
      |                                                                    ^~~~~~~~~
/data/exact-penalty/pyver/src/pointWork.cpp:49:25: error: ‘normalizeAndOrthogonalize’ is not a member of ‘Polynomial’
   49 |             Polynomial::normalizeAndOrthogonalize(pivotPolynomial, nextPosition, newPointShifted, dim, pointsNum);
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/pointWork.cpp:50:57: error: no matching function for call to ‘Polynomial::orthogonalizeBlock(PolynomialPtr&, Eigen::VectorXd&, int&, int&, int)’
   50 |         pivotPolynomial = Polynomial::orthogonalizeBlock(pivotPolynomial, newPointShifted, nextPosition, blockBeginning,
      |                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   51 |                                                          nextPosition - 1);
      |                                                          ~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:180:29: note: candidate: ‘std::vector<Polynomial> Polynomial::orthogonalizeBlock(const std::vector<Polynomial>&, const Eigen::VectorXd&, int, int)’
  180 |     std::vector<Polynomial> orthogonalizeBlock(const std::vector<Polynomial> &polynomials, const Eigen::VectorXd &point,
      |                             ^~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:180:29: note:   candidate expects 4 arguments, 5 provided
/data/exact-penalty/pyver/src/pointWork.cpp: In function ‘std::pair<std::shared_ptr<TRModel>, bool> chooseAndReplacePoint(TRModelPtr&, Function* const&, const Eigen::VectorXd&, const Eigen::VectorXd&, const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/pointWork.cpp:79:44: error: binding reference of type ‘Eigen::VectorXd&’ {aka ‘Eigen::Matrix<double, -1, 1>&’} to ‘const Eigen::VectorXd’ {aka ‘const Eigen::Matrix<double, -1, 1>’} discards qualifiers
   79 |     Eigen::VectorXd blShifted = shiftPoint(bl, shiftCenter);
      |                                            ^~
/data/exact-penalty/pyver/src/Helpers.hpp:5:46: note:   initializing argument 1 of ‘Eigen::VectorXd& shiftPoint(Eigen::VectorXd&, const Eigen::VectorXd&)’
    5 | Eigen::VectorXd& shiftPoint(Eigen::VectorXd& x, const Eigen::VectorXd& shift_center) {
      |                             ~~~~~~~~~~~~~~~~~^
/data/exact-penalty/pyver/src/pointWork.cpp:80:44: error: binding reference of type ‘Eigen::VectorXd&’ {aka ‘Eigen::Matrix<double, -1, 1>&’} to ‘const Eigen::VectorXd’ {aka ‘const Eigen::Matrix<double, -1, 1>’} discards qualifiers
   80 |     Eigen::VectorXd buShifted = shiftPoint(bu, shiftCenter);
      |                                            ^~
/data/exact-penalty/pyver/src/Helpers.hpp:5:46: note:   initializing argument 1 of ‘Eigen::VectorXd& shiftPoint(Eigen::VectorXd&, const Eigen::VectorXd&)’
    5 | Eigen::VectorXd& shiftPoint(Eigen::VectorXd& x, const Eigen::VectorXd& shift_center) {
      |                             ~~~~~~~~~~~~~~~~~^
/data/exact-penalty/pyver/src/pointWork.cpp:82:46: error: no matching function for call to ‘abs(Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type)’
   82 |     std::vector<int> pivotOrder = argsort(abs(pivotValues.head(pointsNum)));
      |                                           ~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:406:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/GlobalFunctions.h:84:34: note: candidate: ‘template<class Derived> const Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs_op<typename Derived::Scalar>, const Derived> Eigen::abs(const ArrayBase<Derived>&)’
   84 | EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(abs, scalar_abs_op, absolute value,\sa ArrayBase::abs DOXCOMMA MatrixBase::cwiseAbs)
      |                                  ^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/GlobalFunctions.h:31:103: note: in definition of macro ‘EIGEN_ARRAY_DECLARE_GLOBAL_UNARY’
   31 |   inline const Eigen::CwiseUnaryOp<Eigen::internal::FUNCTOR<typename Derived::Scalar>, const Derived>(NAME)(    \
      |                                                                                                       ^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/GlobalFunctions.h:84:34: note:   template argument deduction/substitution failed:
   84 | EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(abs, scalar_abs_op, absolute value,\sa ArrayBase::abs DOXCOMMA MatrixBase::cwiseAbs)
      |                                  ^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/GlobalFunctions.h:31:103: note: in definition of macro ‘EIGEN_ARRAY_DECLARE_GLOBAL_UNARY’
   31 |   inline const Eigen::CwiseUnaryOp<Eigen::internal::FUNCTOR<typename Derived::Scalar>, const Derived>(NAME)(    \
      |                                                                                                       ^~~~
/data/exact-penalty/pyver/src/pointWork.cpp:82:46: note:   ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} is not derived from ‘const Eigen::ArrayBase<Derived>’
   82 |     std::vector<int> pivotOrder = argsort(abs(pivotValues.head(pointsNum)));
      |                                           ~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:38,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/cmath:49:
/usr/include/stdlib.h:980:12: note: candidate: ‘int abs(int)’
  980 | extern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;
      |            ^~~
/usr/include/stdlib.h:980:21: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘int’
  980 | extern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;
      |                 ~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:137:3: note: candidate: ‘constexpr __double128 std::abs(__double128)’
  137 |   abs(__double128 __x)
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:137:18: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘__double128’
  137 |   abs(__double128 __x)
      |       ~~~~~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:85:3: note: candidate: ‘constexpr __int128 std::abs(__int128)’
   85 |   abs(__GLIBCXX_TYPE_INT_N_0 __x) { return __x >= 0 ? __x : -__x; }
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:85:30: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘__int128’
   85 |   abs(__GLIBCXX_TYPE_INT_N_0 __x) { return __x >= 0 ? __x : -__x; }
      |                              ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:79:3: note: candidate: ‘constexpr long double std::abs(long double)’
   79 |   abs(long double __x)
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:79:19: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘long double’
   79 |   abs(long double __x)
      |       ~~~~~~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:75:3: note: candidate: ‘constexpr double std::abs(double)’
   75 |   abs(double __x)
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:75:13: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘double’
   75 |   abs(double __x)
      |       ~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:71:3: note: candidate: ‘constexpr double std::abs(double)’
   71 |   abs(double __x)
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:71:14: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘double’
   71 |   abs(double __x)
      |       ~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:61:3: note: candidate: ‘long long int std::abs(long long int)’
   61 |   abs(long long __x) { return __builtin_llabs (__x); }
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:61:17: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘long long int’
   61 |   abs(long long __x) { return __builtin_llabs (__x); }
      |       ~~~~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:56:3: note: candidate: ‘long int std::abs(long int)’
   56 |   abs(long __i) { return __builtin_labs(__i); }
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:56:12: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘long int’
   56 |   abs(long __i) { return __builtin_labs(__i); }
      |       ~~~~~^~~
/data/exact-penalty/pyver/src/pointWork.cpp:82:35: error: ‘argsort’ was not declared in this scope; did you mean ‘qsort’?
   82 |     std::vector<int> pivotOrder = argsort(abs(pivotValues.head(pointsNum)));
      |                                   ^~~~~~~
      |                                   qsort
/data/exact-penalty/pyver/src/pointWork.cpp:93:109: error: no matching function for call to ‘Polynomial::maximizePolynomialAbs(__gnu_cxx::__alloc_traits<std::allocator<std::shared_ptr<Polynomial> >, std::shared_ptr<Polynomial> >::value_type&, Eigen::VectorXd&, double&, Eigen::VectorXd&, Eigen::VectorXd&, Eigen::VectorXd&)’
   93 |         std::tie(newPointShifted, newPivotValue, newFValues, fSucceeded) = Polynomial::maximizePolynomialAbs(
      |                                                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
   94 |             pivotPolynomial[pos], trCenterX, radius, blShifted, buShifted, shiftCenter);
      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                      
/data/exact-penalty/pyver/src/Polynomials.hpp:120:5: note: candidate: ‘std::tuple<Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, bool> Polynomial::maximizePolynomialAbs(const Eigen::VectorXd&, double, const Eigen::VectorXd&, const Eigen::VectorXd&)’
  120 |     maximizePolynomialAbs(const Eigen::VectorXd &point, double radius, const Eigen::VectorXd &lb,
      |     ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:120:5: note:   candidate expects 4 arguments, 6 provided
/data/exact-penalty/pyver/src/pointWork.cpp:99:32: error: base operand of ‘->’ has non-pointer type ‘std::vector<std::shared_ptr<Polynomial> >’
   99 |                 pivotPolynomial->normalizePolynomial(new_point_shifted);
      |                                ^~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h: In instantiation of ‘constexpr std::_Vector_base<_Tp, _Alloc>::~_Vector_base() [with _Tp = Polynomial; _Alloc = std::allocator<Polynomial>]’:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:738:7:   required from ‘constexpr std::vector<_Tp, _Alloc>::~vector() [with _Tp = Polynomial; _Alloc = std::allocator<Polynomial>]’
/data/exact-penalty/pyver/src/TRModel.hpp:174:64:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:370:49: error: invalid use of incomplete type ‘class Polynomial’
  370 |                       _M_impl._M_end_of_storage - _M_impl._M_start);
      |                       ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Definitions.hpp:20:7: note: forward declaration of ‘class Polynomial’
   20 | class Polynomial;
      |       ^~~~~~~~~~
/data/exact-penalty/pyver/src/pointWork.cpp:99:54: error: ‘new_point_shifted’ was not declared in this scope; did you mean ‘newPointShifted’?
   99 |                 pivotPolynomial->normalizePolynomial(new_point_shifted);
      |                                                      ^~~~~~~~~~~~~~~~~
      |                                                      newPointShifted
/data/exact-penalty/pyver/src/pointWork.cpp:100:32: error: base operand of ‘->’ has non-pointer type ‘std::vector<std::shared_ptr<Polynomial> >’
  100 |                 pivotPolynomial->orthogonalizeToOtherPolynomials(pivotPolynomials, pos, newPointShifted, pointsNum);
      |                                ^~
/data/exact-penalty/pyver/src/pointWork.cpp:100:66: error: ‘pivotPolynomials’ was not declared in this scope; did you mean ‘pivotPolynomial’?
  100 |                 pivotPolynomial->orthogonalizeToOtherPolynomials(pivotPolynomials, pos, newPointShifted, pointsNum);
      |                                                                  ^~~~~~~~~~~~~~~~
      |                                                                  pivotPolynomial
/data/exact-penalty/pyver/src/pointWork.cpp: In function ‘std::pair<std::shared_ptr<TRModel>, bool> improveModelNFP(TRModelPtr&, Function* const&, const Eigen::VectorXd&, const Eigen::VectorXd&, const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/pointWork.cpp:136:58: error: no match for ‘operator=’ (operand types are ‘const Eigen::VectorXd’ {aka ‘const Eigen::Matrix<double, -1, 1>’} and ‘const Eigen::DenseBase<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >::NegativeReturnType’ {aka ‘const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >’})
  136 |     if (bl.size() == 0) { bl = -Eigen::VectorXd::Ones(dim); }
      |                                                          ^
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:314:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:264:59: note: candidate: ‘constexpr Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>& Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::operator=(Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>&&) [with Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’ (near match)
  264 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE constexpr Matrix& operator=(Matrix&& other)
      |                                                           ^~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:264:59: note:   passing ‘const Eigen::VectorXd*’ {aka ‘const Eigen::Matrix<double, -1, 1>*’} as ‘this’ argument discards qualifiers
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:210:59: note: candidate: ‘constexpr Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>& Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::operator=(const Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>&) [with Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’ (near match)
  210 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE constexpr Matrix& operator=(const Matrix& other) { return Base::_set(other); }
      |                                                           ^~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:210:59: note:   passing ‘const Eigen::VectorXd*’ {aka ‘const Eigen::Matrix<double, -1, 1>*’} as ‘this’ argument discards qualifiers
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:398:29: note: candidate: ‘template<class OtherDerived> Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>& Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::operator=(const Eigen::RotationBase<OtherDerived, Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::ColsAtCompileTime>&) [with Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’
  398 |   EIGEN_DEVICE_FUNC Matrix& operator=(const RotationBase<OtherDerived, ColsAtCompileTime>& r);
      |                             ^~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:398:29: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/pointWork.cpp:136:58: note:   ‘const Eigen::DenseBase<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >::NegativeReturnType’ {aka ‘const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >’} is not derived from ‘const Eigen::RotationBase<OtherDerived, 1>’
  136 |     if (bl.size() == 0) { bl = -Eigen::VectorXd::Ones(dim); }
      |                                                          ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:239:49: note: candidate: ‘template<class OtherDerived> Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>& Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’
  239 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Matrix& operator=(const ReturnByValue<OtherDerived>& func) {
      |                                                 ^~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:239:49: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/pointWork.cpp:136:58: note:   ‘const Eigen::DenseBase<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >::NegativeReturnType’ {aka ‘const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >’} is not derived from ‘const Eigen::ReturnByValue<Derived>’
  136 |     if (bl.size() == 0) { bl = -Eigen::VectorXd::Ones(dim); }
      |                                                          ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:234:49: note: candidate: ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>& Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’ (near match)
  234 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Matrix& operator=(const EigenBase<OtherDerived>& other) {
      |                                                 ^~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:234:49: note:   passing ‘const Eigen::VectorXd*’ {aka ‘const Eigen::Matrix<double, -1, 1>*’} as ‘this’ argument discards qualifiers
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:223:49: note: candidate: ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>& Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’ (near match)
  223 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Matrix& operator=(const DenseBase<OtherDerived>& other) {
      |                                                 ^~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:223:49: note:   passing ‘const Eigen::VectorXd*’ {aka ‘const Eigen::Matrix<double, -1, 1>*’} as ‘this’ argument discards qualifiers
/data/exact-penalty/pyver/src/pointWork.cpp:137:57: error: no match for ‘operator=’ (operand types are ‘const Eigen::VectorXd’ {aka ‘const Eigen::Matrix<double, -1, 1>’} and ‘const Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::ConstantReturnType’ {aka ‘const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >’})
  137 |     if (bu.size() == 0) { bu = Eigen::VectorXd::Ones(dim); }
      |                                                         ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:264:59: note: candidate: ‘constexpr Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>& Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::operator=(Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>&&) [with Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’ (near match)
  264 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE constexpr Matrix& operator=(Matrix&& other)
      |                                                           ^~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:264:59: note:   passing ‘const Eigen::VectorXd*’ {aka ‘const Eigen::Matrix<double, -1, 1>*’} as ‘this’ argument discards qualifiers
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:210:59: note: candidate: ‘constexpr Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>& Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::operator=(const Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>&) [with Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’ (near match)
  210 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE constexpr Matrix& operator=(const Matrix& other) { return Base::_set(other); }
      |                                                           ^~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:210:59: note:   passing ‘const Eigen::VectorXd*’ {aka ‘const Eigen::Matrix<double, -1, 1>*’} as ‘this’ argument discards qualifiers
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:398:29: note: candidate: ‘template<class OtherDerived> Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>& Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::operator=(const Eigen::RotationBase<OtherDerived, Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::ColsAtCompileTime>&) [with Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’
  398 |   EIGEN_DEVICE_FUNC Matrix& operator=(const RotationBase<OtherDerived, ColsAtCompileTime>& r);
      |                             ^~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:398:29: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/pointWork.cpp:137:57: note:   ‘const Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::ConstantReturnType’ {aka ‘const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >’} is not derived from ‘const Eigen::RotationBase<OtherDerived, 1>’
  137 |     if (bu.size() == 0) { bu = Eigen::VectorXd::Ones(dim); }
      |                                                         ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:239:49: note: candidate: ‘template<class OtherDerived> Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>& Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’
  239 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Matrix& operator=(const ReturnByValue<OtherDerived>& func) {
      |                                                 ^~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:239:49: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/pointWork.cpp:137:57: note:   ‘const Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::ConstantReturnType’ {aka ‘const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >’} is not derived from ‘const Eigen::ReturnByValue<Derived>’
  137 |     if (bu.size() == 0) { bu = Eigen::VectorXd::Ones(dim); }
      |                                                         ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:234:49: note: candidate: ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>& Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’ (near match)
  234 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Matrix& operator=(const EigenBase<OtherDerived>& other) {
      |                                                 ^~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:234:49: note:   passing ‘const Eigen::VectorXd*’ {aka ‘const Eigen::Matrix<double, -1, 1>*’} as ‘this’ argument discards qualifiers
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:223:49: note: candidate: ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>& Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’ (near match)
  223 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Matrix& operator=(const DenseBase<OtherDerived>& other) {
      |                                                 ^~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:223:49: note:   passing ‘const Eigen::VectorXd*’ {aka ‘const Eigen::Matrix<double, -1, 1>*’} as ‘this’ argument discards qualifiers
/data/exact-penalty/pyver/src/pointWork.cpp:141:44: error: binding reference of type ‘Eigen::VectorXd&’ {aka ‘Eigen::Matrix<double, -1, 1>&’} to ‘const Eigen::VectorXd’ {aka ‘const Eigen::Matrix<double, -1, 1>’} discards qualifiers
  141 |     Eigen::VectorXd blShifted = shiftPoint(bl);
      |                                            ^~
/data/exact-penalty/pyver/src/Helpers.hpp:5:46: note: in passing argument 1 of ‘Eigen::VectorXd& shiftPoint(Eigen::VectorXd&, const Eigen::VectorXd&)’
    5 | Eigen::VectorXd& shiftPoint(Eigen::VectorXd& x, const Eigen::VectorXd& shift_center) {
      |                             ~~~~~~~~~~~~~~~~~^
/data/exact-penalty/pyver/src/pointWork.cpp:142:44: error: binding reference of type ‘Eigen::VectorXd&’ {aka ‘Eigen::Matrix<double, -1, 1>&’} to ‘const Eigen::VectorXd’ {aka ‘const Eigen::Matrix<double, -1, 1>’} discards qualifiers
  142 |     Eigen::VectorXd buShifted = shiftPoint(bu);
      |                                            ^~
/data/exact-penalty/pyver/src/Helpers.hpp:5:46: note: in passing argument 1 of ‘Eigen::VectorXd& shiftPoint(Eigen::VectorXd&, const Eigen::VectorXd&)’
    5 | Eigen::VectorXd& shiftPoint(Eigen::VectorXd& x, const Eigen::VectorXd& shift_center) {
      |                             ~~~~~~~~~~~~~~~~~^
/data/exact-penalty/pyver/src/pointWork.cpp:172:56: error: no matching function for call to ‘Polynomial::orthogonalizeToOtherPolynomials(std::vector<std::shared_ptr<Polynomial> >&, Eigen::MatrixXd&, int&)’
  172 |             polynomial->orthogonalizeToOtherPolynomials(pivotPolynomials, pointsShifted, pIni);
      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:67:16: note: candidate: ‘Polynomial Polynomial::orthogonalizeToOtherPolynomials(const std::vector<std::shared_ptr<Polynomial> >&, int, const Eigen::MatrixXd&, int)’
   67 |     Polynomial orthogonalizeToOtherPolynomials(const std::vector<PolynomialPtr> &allPolynomials, int polyIndex,
      |                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:67:16: note:   candidate expects 4 arguments, 3 provided
/data/exact-penalty/pyver/src/pointWork.cpp:173:106: error: no matching function for call to ‘Polynomial::maximizePolynomialAbs(Eigen::VectorXd&, double&, Eigen::VectorXd&, Eigen::VectorXd&, Eigen::VectorXd& (&)(Eigen::VectorXd&, const Eigen::VectorXd&), Eigen::VectorXd& (&)(Eigen::VectorXd&, const Eigen::VectorXd&, const Eigen::VectorXd&, const Eigen::VectorXd&))’
  173 |             std::tie(newPointsShifted, newPivots, newPointsUnshifted) = polynomial->maximizePolynomialAbs(
      |                                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
  174 |                 trCenterPt, radiusUsed, blShifted, buShifted, shiftPoint, unshiftPoint);
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                   
/data/exact-penalty/pyver/src/Polynomials.hpp:120:5: note: candidate: ‘std::tuple<Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, bool> Polynomial::maximizePolynomialAbs(const Eigen::VectorXd&, double, const Eigen::VectorXd&, const Eigen::VectorXd&)’
  120 |     maximizePolynomialAbs(const Eigen::VectorXd &point, double radius, const Eigen::VectorXd &lb,
      |     ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:120:5: note:   candidate expects 4 arguments, 6 provided
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In instantiation of ‘struct std::is_destructible<Polynomial>’:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_construct.h:188:51:   required from ‘constexpr void std::_Destroy(_ForwardIterator, _ForwardIterator) [with _ForwardIterator = Polynomial*]’
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/alloc_traits.h:948:20:   required from ‘constexpr void std::_Destroy(_ForwardIterator, _ForwardIterator, allocator<_T2>&) [with _ForwardIterator = Polynomial*; _Tp = Polynomial]’
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:735:15:   required from ‘constexpr std::vector<_Tp, _Alloc>::~vector() [with _Tp = Polynomial; _Alloc = std::allocator<Polynomial>]’
/data/exact-penalty/pyver/src/TRModel.hpp:174:64:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:979:52: error: static assertion failed: template argument must be a complete class or an unbounded array
  979 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:979:52: note: ‘std::__is_complete_or_unbounded<__type_identity<Polynomial> >((std::__type_identity<Polynomial>(), std::__type_identity<Polynomial>()))’ evaluates to false
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/char_traits.h:57,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/ios:42:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_construct.h: In instantiation of ‘constexpr void std::_Destroy(_ForwardIterator, _ForwardIterator) [with _ForwardIterator = Polynomial*]’:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/alloc_traits.h:948:20:   required from ‘constexpr void std::_Destroy(_ForwardIterator, _ForwardIterator, allocator<_T2>&) [with _ForwardIterator = Polynomial*; _Tp = Polynomial]’
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:735:15:   required from ‘constexpr std::vector<_Tp, _Alloc>::~vector() [with _Tp = Polynomial; _Alloc = std::allocator<Polynomial>]’
/data/exact-penalty/pyver/src/TRModel.hpp:174:64:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_construct.h:188:51: error: static assertion failed: value type is destructible
  188 |       static_assert(is_destructible<_Value_type>::value,
      |                                                   ^~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_construct.h:188:51: note: ‘std::integral_constant<bool, false>::value’ evaluates to false
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_construct.h:195:25: error: invalid use of incomplete type ‘using std::iterator_traits<Polynomial*>::value_type = std::remove_cv_t<Polynomial>’ {aka ‘class Polynomial’} [-fpermissive]
  195 |       std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Definitions.hpp:20:7: note: forward declaration of ‘using std::iterator_traits<Polynomial*>::value_type = std::remove_cv_t<Polynomial>’ {aka ‘class Polynomial’}
   20 | class Polynomial;
      |       ^~~~~~~~~~
/data/exact-penalty/pyver/src/pointWork.cpp:186:52: error: ‘evaluateNewFValues’ was not declared in this scope; did you mean ‘evaluate_new_fvalues’?
  186 |                 std::tie(newFValues, fSucceeded) = evaluateNewFValues(funcs, newPointAbs);
      |                                                    ^~~~~~~~~~~~~~~~~~
      |                                                    evaluate_new_fvalues
/data/exact-penalty/pyver/src/pointWork.cpp:215:43: error: no matching function for call to ‘Polynomial::orthogonalizeBlock(std::vector<std::shared_ptr<Polynomial> >&, Eigen::VectorXd&, int&, int&, int&)’
  215 |             Polynomial::orthogonalizeBlock(pivotPolynomials, newPointShifted, nextPosition, blockBeginning, pIni);
      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:180:29: note: candidate: ‘std::vector<Polynomial> Polynomial::orthogonalizeBlock(const std::vector<Polynomial>&, const Eigen::VectorXd&, int, int)’
  180 |     std::vector<Polynomial> orthogonalizeBlock(const std::vector<Polynomial> &polynomials, const Eigen::VectorXd &point,
      |                             ^~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:180:29: note:   candidate expects 4 arguments, 5 provided
/data/exact-penalty/pyver/src/Helpers.hpp: In function ‘std::pair<Eigen::Matrix<double, -1, 1>, bool> evaluate_new_fvalues(Function* const&, const Eigen::VectorXd&)’:
/data/exact-penalty/pyver/src/Helpers.hpp:19:31: error: request for member ‘size’ in ‘funcs’, which is of pointer type ‘const Functions’ {aka ‘Function* const’} (maybe you meant to use ‘->’ ?)
   19 |     int functions_num = funcs.size();
      |                               ^~~~
/data/exact-penalty/pyver/src/Helpers.hpp:24:36: error: no match for call to ‘(Function) (const Eigen::VectorXd&)’
   24 |             fvalues(nf) = funcs[nf](point);
      |                           ~~~~~~~~~^~~~~~~
/data/exact-penalty/pyver/src/Aux.cpp: In function ‘int changeTRCenter(TRModelPtr&, const Eigen::VectorXd&, const Eigen::VectorXd&, const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/Aux.cpp:76:51: error: cannot convert ‘const Eigen::VectorXd’ {aka ‘const Eigen::Matrix<double, -1, 1>’} to ‘Eigen::DenseCoeffsBase<Eigen::Matrix<double, -1, 1>, 1>::Scalar’ {aka ‘double’} in assignment
   76 |       model->fValues(model->fValues.size() - 1) = newFValues;
      |                                                   ^~~~~~~~~~
      |                                                   |
      |                                                   const Eigen::VectorXd {aka const Eigen::Matrix<double, -1, 1>}
/data/exact-penalty/pyver/src/Aux.cpp:79:11: error: ‘rebuildTRModelPtr’ was not declared in this scope
   79 |           rebuildTRModelPtr(model, options); // Assume rebuildTRModelPtr is implemented
      |           ^~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Aux.cpp: In function ‘int ensureImprovement(TRModelPtr&, const Function&, const Eigen::VectorXd&, const Eigen::VectorXd&, const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/Aux.cpp:98:55: error: invalid initialization of reference of type ‘Function* const&’ from expression of type ‘const Function’
   98 |     std::tie(model, success) = improveModelNFP(model, funcs, bl, bu, options);
      |                                                       ^~~~~
In file included from /data/exact-penalty/pyver/src/Aux.cpp:16:
/data/exact-penalty/pyver/src/pointWork.hpp:19:81: note: in passing argument 2 of ‘std::pair<std::shared_ptr<TRModel>, bool> improveModelNFP(TRModelPtr&, Function* const&, const Eigen::VectorXd&, const Eigen::VectorXd&, const std::map<std::__cxx11::basic_string<char>, double>&)’
   19 | std::pair<TRModelPtr, bool> improveModelNFP(TRModelPtr &model, const Functions &funcs, const Eigen::VectorXd &bl,
      |                                                                ~~~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/Aux.cpp:104:38: error: invalid initialization of reference of type ‘Function* const&’ from expression of type ‘const Function’
  104 |         chooseAndReplacePoint(model, funcs, bl, bu, options);
      |                                      ^~~~~
/data/exact-penalty/pyver/src/pointWork.hpp:15:87: note: in passing argument 2 of ‘std::pair<std::shared_ptr<TRModel>, bool> chooseAndReplacePoint(TRModelPtr&, Function* const&, const Eigen::VectorXd&, const Eigen::VectorXd&, const std::map<std::__cxx11::basic_string<char>, double>&)’
   15 | std::pair<TRModelPtr, bool> chooseAndReplacePoint(TRModelPtr &model, const Functions &funcs, const Eigen::VectorXd &bl,
      |                                                                      ~~~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/Aux.cpp: In function ‘std::pair<std::shared_ptr<TRModel>, bool> chooseAndReplacePoint(TRModelPtr&, Function* const&, const Eigen::VectorXd&, const Eigen::VectorXd&, const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/Aux.cpp:138:44: error: binding reference of type ‘Eigen::VectorXd&’ {aka ‘Eigen::Matrix<double, -1, 1>&’} to ‘const Eigen::VectorXd’ {aka ‘const Eigen::Matrix<double, -1, 1>’} discards qualifiers
  138 |     Eigen::VectorXd blShifted = shiftPoint(bl, shiftCenter);
      |                                            ^~
/data/exact-penalty/pyver/src/Helpers.hpp:5:46: note:   initializing argument 1 of ‘Eigen::VectorXd& shiftPoint(Eigen::VectorXd&, const Eigen::VectorXd&)’
    5 | Eigen::VectorXd& shiftPoint(Eigen::VectorXd& x, const Eigen::VectorXd& shift_center) {
      |                             ~~~~~~~~~~~~~~~~~^
/data/exact-penalty/pyver/src/Aux.cpp:139:44: error: binding reference of type ‘Eigen::VectorXd&’ {aka ‘Eigen::Matrix<double, -1, 1>&’} to ‘const Eigen::VectorXd’ {aka ‘const Eigen::Matrix<double, -1, 1>’} discards qualifiers
  139 |     Eigen::VectorXd buShifted = shiftPoint(bu, shiftCenter);
      |                                            ^~
/data/exact-penalty/pyver/src/Helpers.hpp:5:46: note:   initializing argument 1 of ‘Eigen::VectorXd& shiftPoint(Eigen::VectorXd&, const Eigen::VectorXd&)’
    5 | Eigen::VectorXd& shiftPoint(Eigen::VectorXd& x, const Eigen::VectorXd& shift_center) {
      |                             ~~~~~~~~~~~~~~~~~^
/data/exact-penalty/pyver/src/Aux.cpp:141:46: error: no matching function for call to ‘abs(Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type)’
  141 |     std::vector<int> pivotOrder = argsort(abs(pivotValues.head(pointsNum)));
      |                                           ~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:406:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/GlobalFunctions.h:84:34: note: candidate: ‘template<class Derived> const Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs_op<typename Derived::Scalar>, const Derived> Eigen::abs(const ArrayBase<Derived>&)’
   84 | EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(abs, scalar_abs_op, absolute value,\sa ArrayBase::abs DOXCOMMA MatrixBase::cwiseAbs)
      |                                  ^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/GlobalFunctions.h:31:103: note: in definition of macro ‘EIGEN_ARRAY_DECLARE_GLOBAL_UNARY’
   31 |   inline const Eigen::CwiseUnaryOp<Eigen::internal::FUNCTOR<typename Derived::Scalar>, const Derived>(NAME)(    \
      |                                                                                                       ^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/GlobalFunctions.h:84:34: note:   template argument deduction/substitution failed:
   84 | EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(abs, scalar_abs_op, absolute value,\sa ArrayBase::abs DOXCOMMA MatrixBase::cwiseAbs)
      |                                  ^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/GlobalFunctions.h:31:103: note: in definition of macro ‘EIGEN_ARRAY_DECLARE_GLOBAL_UNARY’
   31 |   inline const Eigen::CwiseUnaryOp<Eigen::internal::FUNCTOR<typename Derived::Scalar>, const Derived>(NAME)(    \
      |                                                                                                       ^~~~
/data/exact-penalty/pyver/src/Aux.cpp:141:46: note:   ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} is not derived from ‘const Eigen::ArrayBase<Derived>’
  141 |     std::vector<int> pivotOrder = argsort(abs(pivotValues.head(pointsNum)));
      |                                           ~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/cstdlib:79,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/ext/string_conversions.h:43,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/basic_string.h:4109,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/string:54:
/usr/include/stdlib.h:980:12: note: candidate: ‘int abs(int)’
  980 | extern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;
      |            ^~~
/usr/include/stdlib.h:980:21: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘int’
  980 | extern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;
      |                 ~~~~^~~
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/cstdlib:81:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:137:3: note: candidate: ‘constexpr __double128 std::abs(__double128)’
  137 |   abs(__double128 __x)
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:137:18: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘__double128’
  137 |   abs(__double128 __x)
      |       ~~~~~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:85:3: note: candidate: ‘constexpr __int128 std::abs(__int128)’
   85 |   abs(__GLIBCXX_TYPE_INT_N_0 __x) { return __x >= 0 ? __x : -__x; }
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:85:30: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘__int128’
   85 |   abs(__GLIBCXX_TYPE_INT_N_0 __x) { return __x >= 0 ? __x : -__x; }
      |                              ^
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:79:3: note: candidate: ‘constexpr long double std::abs(long double)’
   79 |   abs(long double __x)
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:79:19: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘long double’
   79 |   abs(long double __x)
      |       ~~~~~~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:75:3: note: candidate: ‘constexpr double std::abs(double)’
   75 |   abs(double __x)
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:75:13: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘double’
   75 |   abs(double __x)
      |       ~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:71:3: note: candidate: ‘constexpr double std::abs(double)’
   71 |   abs(double __x)
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:71:14: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘double’
   71 |   abs(double __x)
      |       ~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:61:3: note: candidate: ‘long long int std::abs(long long int)’
   61 |   abs(long long __x) { return __builtin_llabs (__x); }
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:61:17: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘long long int’
   61 |   abs(long long __x) { return __builtin_llabs (__x); }
      |       ~~~~~~~~~~^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:56:3: note: candidate: ‘long int std::abs(long int)’
   56 |   abs(long __i) { return __builtin_labs(__i); }
      |   ^~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/std_abs.h:56:12: note:   no known conversion for argument 1 from ‘Eigen::DenseBase<Eigen::Matrix<double, -1, 1> >::FixedSegmentReturnType<-1>::Type’ {aka ‘Eigen::VectorBlock<Eigen::Matrix<double, -1, 1>, -1>’} to ‘long int’
   56 |   abs(long __i) { return __builtin_labs(__i); }
      |       ~~~~~^~~
/data/exact-penalty/pyver/src/Aux.cpp:154:56: error: no matching function for call to ‘Polynomial::maximizePolynomialAbs(Eigen::VectorXd&, double&, Eigen::VectorXd&, Eigen::VectorXd&, Eigen::VectorXd&)’
  154 |             pivotPolynomial[pos]->maximizePolynomialAbs(trCenterX, radius, blShifted, buShifted, shiftCenter);
      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:120:5: note: candidate: ‘std::tuple<Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, bool> Polynomial::maximizePolynomialAbs(const Eigen::VectorXd&, double, const Eigen::VectorXd&, const Eigen::VectorXd&)’
  120 |     maximizePolynomialAbs(const Eigen::VectorXd &point, double radius, const Eigen::VectorXd &lb,
      |     ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Polynomials.hpp:120:5: note:   candidate expects 4 arguments, 5 provided
/data/exact-penalty/pyver/src/Aux.cpp:159:32: error: base operand of ‘->’ has non-pointer type ‘std::vector<std::shared_ptr<Polynomial> >’
  159 |                 pivotPolynomial->normalizePolynomial(pos);
      |                                ^~
/data/exact-penalty/pyver/src/Aux.cpp:160:32: error: base operand of ‘->’ has non-pointer type ‘std::vector<std::shared_ptr<Polynomial> >’
  160 |                 pivotPolynomial->orthogonalizeToOtherPolynomials(pivotPolynomials, pos, pointsShifted, pointsNum);
      |                                ^~
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/x86_64-pc-linux-gnu/bits/c++allocator.h:33,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/allocator.h:46,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/string:43:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/new_allocator.h: In instantiation of ‘void std::__new_allocator<_Tp>::deallocate(_Tp*, size_type) [with _Tp = Polynomial; size_type = long unsigned int]’:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/allocator.h:210:35:   required from ‘constexpr void std::allocator< <template-parameter-1-1> >::deallocate(_Tp*, std::size_t) [with _Tp = Polynomial; std::size_t = long unsigned int]’
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/alloc_traits.h:517:23:   required from ‘static constexpr void std::allocator_traits<std::allocator<_CharT> >::deallocate(allocator_type&, pointer, size_type) [with _Tp = Polynomial; allocator_type = std::allocator<Polynomial>; pointer = Polynomial*; size_type = long unsigned int]’
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:390:19:   required from ‘constexpr void std::_Vector_base<_Tp, _Alloc>::_M_deallocate(pointer, std::size_t) [with _Tp = Polynomial; _Alloc = std::allocator<Polynomial>; pointer = Polynomial*; std::size_t = long unsigned int]’
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:369:2:   required from ‘constexpr std::_Vector_base<_Tp, _Alloc>::~_Vector_base() [with _Tp = Polynomial; _Alloc = std::allocator<Polynomial>]’
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_vector.h:738:7:   required from ‘constexpr std::vector<_Tp, _Alloc>::~vector() [with _Tp = Polynomial; _Alloc = std::allocator<Polynomial>]’
/data/exact-penalty/pyver/src/TRModel.hpp:174:64:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/new_allocator.h:165:13: error: invalid application of ‘__alignof__’ to incomplete type ‘Polynomial’
  165 |         if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
      |             ^~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/new_allocator.h:167:38: error: invalid application of ‘sizeof’ to incomplete type ‘Polynomial’
  167 |             _GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n),
      |                                      ^~~~~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/new_allocator.h:168:55: error: invalid application of ‘__alignof__’ to incomplete type ‘Polynomial’
  168 |                                      std::align_val_t(alignof(_Tp)));
      |                                                       ^~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/new_allocator.h:172:34: error: invalid application of ‘sizeof’ to incomplete type ‘Polynomial’
  172 |         _GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n));
      |                                  ^~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/Aux.cpp:160:66: error: ‘pivotPolynomials’ was not declared in this scope; did you mean ‘pivotPolynomial’?
  160 |                 pivotPolynomial->orthogonalizeToOtherPolynomials(pivotPolynomials, pos, pointsShifted, pointsNum);
      |                                                                  ^~~~~~~~~~~~~~~~
      |                                                                  pivotPolynomial
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:314:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: error: no matching function for call to ‘Eigen::Matrix<double, -1, -1>::_init1<std::vector<std::vector<double, std::allocator<double> >, std::allocator<std::vector<double, std::allocator<double> > > > >(const std::vector<std::vector<double> >&)’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:313:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:807:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(Eigen::Index, std::enable_if_t<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T>*) [with T = std::vector<std::vector<double> >; Derived = Eigen::Matrix<double, -1, -1>; Eigen::Index = long int; std::enable_if_t<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T> = std::vector<std::vector<double> >; typename Eigen::internal::dense_xpr_base<Derived>::type = Eigen::MatrixBase<Eigen::Matrix<double, -1, -1> >; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr; typename Eigen::internal::traits<T>::Scalar = double; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr]’
  807 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:808:13: note:   no known conversion for argument 1 from ‘const std::vector<std::vector<double> >’ to ‘Eigen::Index’ {aka ‘long int’}
  808 |       Index size,
      |       ~~~~~~^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Scalar&, std::enable_if_t<((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T>*) [with Derived = Eigen::Matrix<double, -1, -1>]’
  823 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46: note:   template argument deduction/substitution failed:
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/move.h:37,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/exception_ptr.h:41,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/exception:164,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/ios:41:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = std::vector<std::vector<double> >]’:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46:   required by substitution of ‘template<class T> void Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::_init1(const Scalar&, std::enable_if_t<((Eigen::MatrixBase<Eigen::Matrix<double, -1, -1> >::SizeAtCompileTime == 1) && std::is_convertible<T, double>::value), T>*) [with T = std::vector<std::vector<double> >]’
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29:   required from ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:2610:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::vector<std::vector<double> > >’
 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
      |           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::Index&, std::enable_if_t<((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T*>*) [with Derived = Eigen::Matrix<double, -1, -1>]’
  833 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46: note:   template argument deduction/substitution failed:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = std::vector<std::vector<double> >*]’:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46:   required by substitution of ‘template<class T> void Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::_init1(const Eigen::Index&, std::enable_if_t<((((! Eigen::internal::is_same<long int, double>::value) && Eigen::internal::is_same<long int, T>::value) && (Eigen::MatrixBase<Eigen::Matrix<double, -1, -1> >::SizeAtCompileTime == 1)) && std::is_convertible<T, double>::value), T*>*) [with T = std::vector<std::vector<double> >]’
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29:   required from ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:2610:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::vector<std::vector<double> >*>’
 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
      |           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:844:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(const Scalar*) [with T = std::vector<std::vector<double> >; Derived = Eigen::Matrix<double, -1, -1>; Scalar = double]’
  844 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Scalar* data) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:844:67: note:   no known conversion for argument 1 from ‘const std::vector<std::vector<double> >’ to ‘const Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::Scalar*’ {aka ‘const double*’}
  844 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Scalar* data) {
      |                                                     ~~~~~~~~~~~~~~^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:850:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, -1>]’
  850 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const DenseBase<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:850:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<std::vector<double> >’ is not derived from ‘const Eigen::DenseBase<Derived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:856:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(const Derived&) [with T = std::vector<std::vector<double> >; Derived = Eigen::Matrix<double, -1, -1>]’
  856 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Derived& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:856:68: note:   no known conversion for argument 1 from ‘const std::vector<std::vector<double> >’ to ‘const Eigen::Matrix<double, -1, -1>&’
  856 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Derived& other) {
      |                                                     ~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:862:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, -1>]’
  862 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const EigenBase<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:862:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<std::vector<double> >’ is not derived from ‘const Eigen::EigenBase<OtherDerived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:867:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, -1>]’
  867 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const ReturnByValue<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:867:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<std::vector<double> >’ is not derived from ‘const Eigen::ReturnByValue<OtherDerived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:873:46: note: candidate: ‘template<class T, class OtherDerived, int ColsAtCompileTime> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>&) [with OtherDerived = T; int ColsAtCompileTime = OtherDerived; Derived = Eigen::Matrix<double, -1, -1>]’
  873 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const RotationBase<OtherDerived, ColsAtCompileTime>& r) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:873:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<std::vector<double> >’ is not derived from ‘const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:879:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Scalar&, std::enable_if_t<((((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T>*) [with Derived = Eigen::Matrix<double, -1, -1>]’
  879 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:879:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:890:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::Index&, std::enable_if_t<((((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic)) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T*>*) [with Derived = Eigen::Matrix<double, -1, -1>]’
  890 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:890:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:30:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: error: no matching function for call to ‘Eigen::Matrix<double, -1, 1>::_init1<std::vector<double, std::allocator<double> > >(const std::vector<double>&)’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:807:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(Eigen::Index, std::enable_if_t<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T>*) [with T = std::vector<double>; Derived = Eigen::Matrix<double, -1, 1>; Eigen::Index = long int; std::enable_if_t<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T> = std::vector<double>; typename Eigen::internal::dense_xpr_base<Derived>::type = Eigen::MatrixBase<Eigen::Matrix<double, -1, 1> >; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr; typename Eigen::internal::traits<T>::Scalar = double; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr]’
  807 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:808:13: note:   no known conversion for argument 1 from ‘const std::vector<double>’ to ‘Eigen::Index’ {aka ‘long int’}
  808 |       Index size,
      |       ~~~~~~^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Scalar&, std::enable_if_t<((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T>*) [with Derived = Eigen::Matrix<double, -1, 1>]’
  823 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46: note:   template argument deduction/substitution failed:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = std::vector<double>]’:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46:   required by substitution of ‘template<class T> void Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 1> >::_init1(const Scalar&, std::enable_if_t<((Eigen::MatrixBase<Eigen::Matrix<double, -1, 1> >::SizeAtCompileTime == 1) && std::is_convertible<T, double>::value), T>*) [with T = std::vector<double>]’
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29:   required from ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’
/data/exact-penalty/pyver/src/TRModel.hpp:31:30:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:2610:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::vector<double> >’
 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
      |           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:30:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::Index&, std::enable_if_t<((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T*>*) [with Derived = Eigen::Matrix<double, -1, 1>]’
  833 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46: note:   template argument deduction/substitution failed:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = std::vector<double>*]’:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46:   required by substitution of ‘template<class T> void Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 1> >::_init1(const Eigen::Index&, std::enable_if_t<((((! Eigen::internal::is_same<long int, double>::value) && Eigen::internal::is_same<long int, T>::value) && (Eigen::MatrixBase<Eigen::Matrix<double, -1, 1> >::SizeAtCompileTime == 1)) && std::is_convertible<T, double>::value), T*>*) [with T = std::vector<double>]’
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29:   required from ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’
/data/exact-penalty/pyver/src/TRModel.hpp:31:30:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:2610:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::vector<double>*>’
 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
      |           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:30:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:844:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(const Scalar*) [with T = std::vector<double>; Derived = Eigen::Matrix<double, -1, 1>; Scalar = double]’
  844 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Scalar* data) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:844:67: note:   no known conversion for argument 1 from ‘const std::vector<double>’ to ‘const Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 1> >::Scalar*’ {aka ‘const double*’}
  844 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Scalar* data) {
      |                                                     ~~~~~~~~~~~~~~^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:850:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, 1>]’
  850 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const DenseBase<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:850:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<double>’ is not derived from ‘const Eigen::DenseBase<Derived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:856:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(const Derived&) [with T = std::vector<double>; Derived = Eigen::Matrix<double, -1, 1>]’
  856 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Derived& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:856:68: note:   no known conversion for argument 1 from ‘const std::vector<double>’ to ‘const Eigen::Matrix<double, -1, 1>&’
  856 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Derived& other) {
      |                                                     ~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:862:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, 1>]’
  862 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const EigenBase<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:862:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<double>’ is not derived from ‘const Eigen::EigenBase<OtherDerived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:867:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, 1>]’
  867 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const ReturnByValue<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:867:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<double>’ is not derived from ‘const Eigen::ReturnByValue<OtherDerived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:873:46: note: candidate: ‘template<class T, class OtherDerived, int ColsAtCompileTime> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>&) [with OtherDerived = T; int ColsAtCompileTime = OtherDerived; Derived = Eigen::Matrix<double, -1, 1>]’
  873 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const RotationBase<OtherDerived, ColsAtCompileTime>& r) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:873:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<double>’ is not derived from ‘const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:879:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Scalar&, std::enable_if_t<((((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T>*) [with Derived = Eigen::Matrix<double, -1, 1>]’
  879 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:879:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:890:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::Index&, std::enable_if_t<((((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic)) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T*>*) [with Derived = Eigen::Matrix<double, -1, 1>]’
  890 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:890:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/pointWork.cpp: In function ‘std::tuple<std::shared_ptr<TRModel>, bool, int> exchangePoint(TRModelPtr&, const Eigen::VectorXd&, const Eigen::VectorXd&, double, bool)’:
/data/exact-penalty/pyver/src/pointWork.cpp:375:79: error: ‘using std::__shared_ptr_access<Polynomial, __gnu_cxx::_S_atomic, false, false>::element_type = class Polynomial’ {aka ‘class Polynomial’} has no member named ‘evaluatePolynomial’
  375 |             double val = model->pivotValues(polyI) * pivotPolynomials[polyI]->evaluatePolynomial(newPointShifted);
      |                                                                               ^~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/pointWork.cpp:395:22: error: expected ‘,’ or ‘;’ before ‘if’
  395 |     int  ptI     = 0 if (std::abs(newPivotVal) > pivotThreshold) {
      |                      ^~
/data/exact-penalty/pyver/src/pointWork.cpp:419:5: error: ‘else’ without a previous ‘if’
  419 |     else {
      |     ^~~~
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:170:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h: In instantiation of ‘Eigen::DenseCoeffsBase<Derived, 0>::CoeffReturnType Eigen::DenseCoeffsBase<Derived, 0>::operator[](Eigen::Index) const [with Derived = Eigen::Matrix<double, -1, -1>; CoeffReturnType = const double&; Eigen::Index = long int]’:
/data/exact-penalty/pyver/src/TRModel.hpp:49:38:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h:141:34: error: static assertion failed: THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD
  141 |     EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
      |                                  ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h:141:34: note: ‘Eigen::Matrix<double, -1, -1>::IsVectorAtCompileTime’ evaluates to false
  141 |     EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
      |                                  ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h: In instantiation of ‘constexpr void Eigen::PlainObjectBase<Derived>::resize(Eigen::Index) [with Derived = Eigen::Matrix<double, -1, -1>; Eigen::Index = long int]’:
/data/exact-penalty/pyver/src/TRModel.hpp:76:29:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:37:29: error: static assertion failed: YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX
   37 |   EIGEN_STATIC_ASSERT(TYPE::IsVectorAtCompileTime, YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX)
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:328:5: note: in expansion of macro ‘EIGEN_STATIC_ASSERT_VECTOR_ONLY’
  328 |     EIGEN_STATIC_ASSERT_VECTOR_ONLY(PlainObjectBase)
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:37:29: note: ‘Eigen::DenseBase<Eigen::Matrix<double, -1, -1> >::IsVectorAtCompileTime’ evaluates to false
   37 |   EIGEN_STATIC_ASSERT(TYPE::IsVectorAtCompileTime, YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX)
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:328:5: note: in expansion of macro ‘EIGEN_STATIC_ASSERT_VECTOR_ONLY’
  328 |     EIGEN_STATIC_ASSERT_VECTOR_ONLY(PlainObjectBase)
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h: In instantiation of ‘Eigen::DenseCoeffsBase<Derived, 1>::Scalar& Eigen::DenseCoeffsBase<Derived, 1>::operator[](Eigen::Index) [with Derived = Eigen::Matrix<double, -1, -1>; Scalar = double; Eigen::Index = long int]’:
/data/exact-penalty/pyver/src/TRModel.hpp:78:92:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h:349:34: error: static assertion failed: THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD
  349 |     EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
      |                                  ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h:349:34: note: ‘Eigen::Matrix<double, -1, -1>::IsVectorAtCompileTime’ evaluates to false
  349 |     EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
      |                                  ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
make[2]: *** [CMakeFiles/l1penalty.dir/build.make:76: CMakeFiles/l1penalty.dir/main.cpp.o] Error 1
make[2]: *** Waiting for unfinished jobs....
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’:
/data/exact-penalty/pyver/src/Polynomials.hpp:17:62:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: error: no matching function for call to ‘Eigen::Matrix<double, -1, 1>::_init1<std::vector<double, std::allocator<double> > >(const std::vector<double>&)’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:313:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:807:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(Eigen::Index, std::enable_if_t<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T>*) [with T = std::vector<double>; Derived = Eigen::Matrix<double, -1, 1>; Eigen::Index = long int; std::enable_if_t<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T> = std::vector<double>; typename Eigen::internal::dense_xpr_base<Derived>::type = Eigen::MatrixBase<Eigen::Matrix<double, -1, 1> >; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr; typename Eigen::internal::traits<T>::Scalar = double; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr]’
  807 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:808:13: note:   no known conversion for argument 1 from ‘const std::vector<double>’ to ‘Eigen::Index’ {aka ‘long int’}
  808 |       Index size,
      |       ~~~~~~^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Scalar&, std::enable_if_t<((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T>*) [with Derived = Eigen::Matrix<double, -1, 1>]’
  823 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46: note:   template argument deduction/substitution failed:
In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_pair.h:60,
                 from /usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/bits/stl_algobase.h:64:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = std::vector<double>]’:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46:   required by substitution of ‘template<class T> void Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 1> >::_init1(const Scalar&, std::enable_if_t<((Eigen::MatrixBase<Eigen::Matrix<double, -1, 1> >::SizeAtCompileTime == 1) && std::is_convertible<T, double>::value), T>*) [with T = std::vector<double>]’
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29:   required from ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’
/data/exact-penalty/pyver/src/Polynomials.hpp:17:62:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:2610:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::vector<double> >’
 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
      |           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’:
/data/exact-penalty/pyver/src/Polynomials.hpp:17:62:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::Index&, std::enable_if_t<((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T*>*) [with Derived = Eigen::Matrix<double, -1, 1>]’
  833 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46: note:   template argument deduction/substitution failed:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = std::vector<double>*]’:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46:   required by substitution of ‘template<class T> void Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 1> >::_init1(const Eigen::Index&, std::enable_if_t<((((! Eigen::internal::is_same<long int, double>::value) && Eigen::internal::is_same<long int, T>::value) && (Eigen::MatrixBase<Eigen::Matrix<double, -1, 1> >::SizeAtCompileTime == 1)) && std::is_convertible<T, double>::value), T*>*) [with T = std::vector<double>]’
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29:   required from ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’
/data/exact-penalty/pyver/src/Polynomials.hpp:17:62:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:2610:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::vector<double>*>’
 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
      |           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<double>; Scalar_ = double; int Rows_ = -1; int Cols_ = 1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = 1]’:
/data/exact-penalty/pyver/src/Polynomials.hpp:17:62:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:844:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(const Scalar*) [with T = std::vector<double>; Derived = Eigen::Matrix<double, -1, 1>; Scalar = double]’
  844 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Scalar* data) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:844:67: note:   no known conversion for argument 1 from ‘const std::vector<double>’ to ‘const Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 1> >::Scalar*’ {aka ‘const double*’}
  844 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Scalar* data) {
      |                                                     ~~~~~~~~~~~~~~^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:850:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, 1>]’
  850 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const DenseBase<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:850:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<double>’ is not derived from ‘const Eigen::DenseBase<Derived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:856:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(const Derived&) [with T = std::vector<double>; Derived = Eigen::Matrix<double, -1, 1>]’
  856 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Derived& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:856:68: note:   no known conversion for argument 1 from ‘const std::vector<double>’ to ‘const Eigen::Matrix<double, -1, 1>&’
  856 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Derived& other) {
      |                                                     ~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:862:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, 1>]’
  862 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const EigenBase<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:862:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<double>’ is not derived from ‘const Eigen::EigenBase<OtherDerived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:867:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, 1>]’
  867 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const ReturnByValue<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:867:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<double>’ is not derived from ‘const Eigen::ReturnByValue<OtherDerived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:873:46: note: candidate: ‘template<class T, class OtherDerived, int ColsAtCompileTime> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>&) [with OtherDerived = T; int ColsAtCompileTime = OtherDerived; Derived = Eigen::Matrix<double, -1, 1>]’
  873 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const RotationBase<OtherDerived, ColsAtCompileTime>& r) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:873:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<double>’ is not derived from ‘const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:879:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Scalar&, std::enable_if_t<((((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T>*) [with Derived = Eigen::Matrix<double, -1, 1>]’
  879 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:879:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:890:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::Index&, std::enable_if_t<((((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic)) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T*>*) [with Derived = Eigen::Matrix<double, -1, 1>]’
  890 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:890:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: error: no matching function for call to ‘Eigen::Matrix<double, -1, -1>::_init1<std::vector<std::vector<double, std::allocator<double> >, std::allocator<std::vector<double, std::allocator<double> > > > >(const std::vector<std::vector<double> >&)’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:807:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(Eigen::Index, std::enable_if_t<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T>*) [with T = std::vector<std::vector<double> >; Derived = Eigen::Matrix<double, -1, -1>; Eigen::Index = long int; std::enable_if_t<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T> = std::vector<std::vector<double> >; typename Eigen::internal::dense_xpr_base<Derived>::type = Eigen::MatrixBase<Eigen::Matrix<double, -1, -1> >; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr; typename Eigen::internal::traits<T>::Scalar = double; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr]’
  807 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:808:13: note:   no known conversion for argument 1 from ‘const std::vector<std::vector<double> >’ to ‘Eigen::Index’ {aka ‘long int’}
  808 |       Index size,
      |       ~~~~~~^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Scalar&, std::enable_if_t<((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T>*) [with Derived = Eigen::Matrix<double, -1, -1>]’
  823 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46: note:   template argument deduction/substitution failed:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = std::vector<std::vector<double> >]’:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:823:46:   required by substitution of ‘template<class T> void Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::_init1(const Scalar&, std::enable_if_t<((Eigen::MatrixBase<Eigen::Matrix<double, -1, -1> >::SizeAtCompileTime == 1) && std::is_convertible<T, double>::value), T>*) [with T = std::vector<std::vector<double> >]’
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29:   required from ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:2610:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::vector<std::vector<double> > >’
 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
      |           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::Index&, std::enable_if_t<((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T*>*) [with Derived = Eigen::Matrix<double, -1, -1>]’
  833 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46: note:   template argument deduction/substitution failed:
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = std::vector<std::vector<double> >*]’:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:833:46:   required by substitution of ‘template<class T> void Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::_init1(const Eigen::Index&, std::enable_if_t<((((! Eigen::internal::is_same<long int, double>::value) && Eigen::internal::is_same<long int, T>::value) && (Eigen::MatrixBase<Eigen::Matrix<double, -1, -1> >::SizeAtCompileTime == 1)) && std::is_convertible<T, double>::value), T*>*) [with T = std::vector<std::vector<double> >]’
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29:   required from ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/usr/lib/gcc/x86_64-pc-linux-gnu/13/include/g++-v13/type_traits:2610:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::vector<std::vector<double> >*>’
 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
      |           ^~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h: In instantiation of ‘Eigen::Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::Matrix(const T&) [with T = std::vector<std::vector<double> >; Scalar_ = double; int Rows_ = -1; int Cols_ = -1; int Options_ = 0; int MaxRows_ = -1; int MaxCols_ = -1]’:
/data/exact-penalty/pyver/src/TRModel.hpp:31:11:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:844:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(const Scalar*) [with T = std::vector<std::vector<double> >; Derived = Eigen::Matrix<double, -1, -1>; Scalar = double]’
  844 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Scalar* data) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:844:67: note:   no known conversion for argument 1 from ‘const std::vector<std::vector<double> >’ to ‘const Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::Scalar*’ {aka ‘const double*’}
  844 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Scalar* data) {
      |                                                     ~~~~~~~~~~~~~~^~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:850:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, -1>]’
  850 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const DenseBase<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:850:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<std::vector<double> >’ is not derived from ‘const Eigen::DenseBase<Derived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:856:46: note: candidate: ‘void Eigen::PlainObjectBase<Derived>::_init1(const Derived&) [with T = std::vector<std::vector<double> >; Derived = Eigen::Matrix<double, -1, -1>]’
  856 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Derived& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:856:68: note:   no known conversion for argument 1 from ‘const std::vector<std::vector<double> >’ to ‘const Eigen::Matrix<double, -1, -1>&’
  856 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const Derived& other) {
      |                                                     ~~~~~~~~~~~~~~~^~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:862:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, -1>]’
  862 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const EigenBase<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:862:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<std::vector<double> >’ is not derived from ‘const Eigen::EigenBase<OtherDerived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:867:46: note: candidate: ‘template<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = T; Derived = Eigen::Matrix<double, -1, -1>]’
  867 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const ReturnByValue<OtherDerived>& other) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:867:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<std::vector<double> >’ is not derived from ‘const Eigen::ReturnByValue<OtherDerived>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:873:46: note: candidate: ‘template<class T, class OtherDerived, int ColsAtCompileTime> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>&) [with OtherDerived = T; int ColsAtCompileTime = OtherDerived; Derived = Eigen::Matrix<double, -1, -1>]’
  873 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(const RotationBase<OtherDerived, ColsAtCompileTime>& r) {
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:873:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/Matrix.h:314:29: note:   ‘const std::vector<std::vector<double> >’ is not derived from ‘const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>’
  314 |     Base::template _init1<T>(x);
      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:879:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Scalar&, std::enable_if_t<((((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T>*) [with Derived = Eigen::Matrix<double, -1, -1>]’
  879 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:879:46: note:   template argument deduction/substitution failed:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:890:46: note: candidate: ‘template<class T> void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::Index&, std::enable_if_t<((((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic)) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T*>*) [with Derived = Eigen::Matrix<double, -1, -1>]’
  890 |   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void _init1(
      |                                              ^~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:890:46: note:   template argument deduction/substitution failed:
In file included from /data/exact-penalty/pyver/src/ext/eigen3/Eigen/Core:170:
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h: In instantiation of ‘Eigen::DenseCoeffsBase<Derived, 0>::CoeffReturnType Eigen::DenseCoeffsBase<Derived, 0>::operator[](Eigen::Index) const [with Derived = Eigen::Matrix<double, -1, -1>; CoeffReturnType = const double&; Eigen::Index = long int]’:
/data/exact-penalty/pyver/src/TRModel.hpp:49:38:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h:141:34: error: static assertion failed: THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD
  141 |     EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
      |                                  ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h:141:34: note: ‘Eigen::Matrix<double, -1, -1>::IsVectorAtCompileTime’ evaluates to false
  141 |     EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
      |                                  ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h: In instantiation of ‘constexpr void Eigen::PlainObjectBase<Derived>::resize(Eigen::Index) [with Derived = Eigen::Matrix<double, -1, -1>; Eigen::Index = long int]’:
/data/exact-penalty/pyver/src/TRModel.hpp:76:29:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:37:29: error: static assertion failed: YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX
   37 |   EIGEN_STATIC_ASSERT(TYPE::IsVectorAtCompileTime, YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX)
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:328:5: note: in expansion of macro ‘EIGEN_STATIC_ASSERT_VECTOR_ONLY’
  328 |     EIGEN_STATIC_ASSERT_VECTOR_ONLY(PlainObjectBase)
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:37:29: note: ‘Eigen::DenseBase<Eigen::Matrix<double, -1, -1> >::IsVectorAtCompileTime’ evaluates to false
   37 |   EIGEN_STATIC_ASSERT(TYPE::IsVectorAtCompileTime, YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX)
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/PlainObjectBase.h:328:5: note: in expansion of macro ‘EIGEN_STATIC_ASSERT_VECTOR_ONLY’
  328 |     EIGEN_STATIC_ASSERT_VECTOR_ONLY(PlainObjectBase)
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h: In instantiation of ‘Eigen::DenseCoeffsBase<Derived, 1>::Scalar& Eigen::DenseCoeffsBase<Derived, 1>::operator[](Eigen::Index) [with Derived = Eigen::Matrix<double, -1, -1>; Scalar = double; Eigen::Index = long int]’:
/data/exact-penalty/pyver/src/TRModel.hpp:78:92:   required from here
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h:349:34: error: static assertion failed: THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD
  349 |     EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
      |                                  ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/DenseCoeffsBase.h:349:34: note: ‘Eigen::Matrix<double, -1, -1>::IsVectorAtCompileTime’ evaluates to false
  349 |     EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
      |                                  ^~~~~~~~~~~~~~~~~~~~~
/data/exact-penalty/pyver/src/ext/eigen3/Eigen/src/Core/util/StaticAssert.h:26:51: note: in definition of macro ‘EIGEN_STATIC_ASSERT’
   26 | #define EIGEN_STATIC_ASSERT(X, MSG) static_assert(X, #MSG);
      |                                                   ^
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘bool TRModel::isLambdaPoised(const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/TRModel.hpp:105:54: warning: control reaches end of non-void function [-Wreturn-type]
  105 |         int    pointsNum      = this->numberOfPoints();
      |                                                      ^
make[2]: *** [CMakeFiles/l1penalty.dir/build.make:90: CMakeFiles/l1penalty.dir/Aux.cpp.o] Error 1
/data/exact-penalty/pyver/src/pointWork.cpp: In function ‘std::pair<std::shared_ptr<TRModel>, bool> improveModelNFP(TRModelPtr&, Function* const&, const Eigen::VectorXd&, const Eigen::VectorXd&, const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/pointWork.cpp:227:1: warning: control reaches end of non-void function [-Wreturn-type]
  227 | }
      | ^
/data/exact-penalty/pyver/src/TRModel.hpp: In member function ‘bool TRModel::isLambdaPoised(const std::map<std::__cxx11::basic_string<char>, double>&)’:
/data/exact-penalty/pyver/src/TRModel.hpp:105:54: warning: control reaches end of non-void function [-Wreturn-type]
  105 |         int    pointsNum      = this->numberOfPoints();
      |                                                      ^
make[2]: *** [CMakeFiles/l1penalty.dir/build.make:104: CMakeFiles/l1penalty.dir/pointWork.cpp.o] Error 1
make[1]: *** [CMakeFiles/Makefile2:83: CMakeFiles/l1penalty.dir/all] Error 2
make: *** [Makefile:91: all] Error 2
